2, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    public List<List<int>> CombinationSum2(int[] candidates, int target) {\n        //CHECK THE HASHMAP AND OPTIMAL VERSIONS ON NEETCODEIO (written ones)?????\n        //WATCH THE NEETCODE VIDEO MAYBE??\n        return backtrack1_PickOrNot(candidates, target);\n    }\n\n\n    public List<List<int>> backtrack1_PickOrNot(int[] candidates, int target) \n    {\n        List<List<int>> res = new();\n        Array.Sort(candidates);\n\n        backtrack1_PickOrNotHelper(\n            candidates,\n            idx: 0,\n            target,\n            curSum: 0,\n            subset: new(candidates.Length),\n            res\n        );\n        return res;\n    }\n\n    public void backtrack1_PickOrNotHelper(int[] candidates, int idx,int target, int curSum, List<int> subset, List<List<int>> res)\n    {\n        if(target == curSum)\n        {\n            res.Add(subset.ToList());\n            return;\n        }\n        if(curSum>target || idx == candidates.Length) //curSum>target => we can't get desired target because all elements >=1 according to constraints.\n            return;\n\n        //Case 1: Pick this\n        subset.Add(candidates[idx]);\n        backtrack1_PickOrNotHelper(candidates, idx+1, target, curSum+candidates[idx], subset, res);\n        subset.RemoveAt(subset.Count-1);\n\n        //Skip repetition of this element (since the above loop takes care of that and we don't want to do it twice(or more)!!!!)\n        while((idx+1)<candidates.Length && candidates[idx]==candidates[(idx+1)])\n            idx++;\n\n        //Case 2: Don't pick this\n        backtrack1_PickOrNotHelper(candidates, idx+1, target, curSum, subset, res);\n        \n        return;\n    }\n}\n",
    "problemId": "combination-target-sum-ii",
    "statusDescription": "Accepted",
    "time": "0.477",
    "date": "2024-11-04T01:59:17.543Z",
    "memory": 54056,
    "stdout": "",
    "stderr": ""
}