8, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    public List<List<int>> SubsetsWithDup(int[] nums) {\n        //READ COMMENTS!!\n        //WATCH NEETCODE VIDEO! (I had to read the written one on neetcodeio)\n        //LOOK AT THE LEETCODEIO SOLN THAT MAKES THIS ITERATIVE!!\n        \n        return backtrack1(nums);\n    }\n    \n    public List<List<int>> backtrack1(int[] nums)\n    {\n        List<List<int>> res = new(1 << nums.Length); //1<<n == 2^n //https://stackoverflow.com/a/10983207\n        \n        //IMPORTANT PART:\n        Array.Sort(nums);\n\n        backtrack1Helper(\n            nums: nums,\n            idx: 0,\n            subset: new(nums.Length),\n            res: res\n        );\n\n        return res;\n    }\n\n    //TC: O(n*2^n) (length of subsets *  number of subsets)\n    //SC: O(n) //subset\n    public void backtrack1Helper(int[] nums, int idx, List<int> subset, List<List<int>> res)\n    {\n        //FOR [2, 2] WE CAN HAVE SUBSETS [2, 2] (where each 2 is from different index) and [2]. Notice there's only ONE [2]. \n        //i.e. A subset may contain the duplicate values more than once, but each subset only appears once so ([2] and [2] are considered the same even if they're 2 from different indices).       \n        \n        //General note: \n        //We CAN (not must) use the binary decision tree when there's NO possibility of NOT picking for each element.\n        //The n-nary decision tree (USING THIS IS ALMOST A MUST WHEN WE MUST PICK AT LEAST ONE ELEMENT FROM THE LIST AT ANY STAGE)\n\n        if(idx == nums.Length)\n        {\n            res.Add(new(subset)); //Use copy constructor to create new reference but same data\n            return;\n        }\n\n        //Case 1: Adding current element\n        subset.Add(nums[idx]);\n        backtrack1Helper(nums, idx+1, subset, res);\n        subset.RemoveAt(subset.Count-1);\n\n        //**IMPORTANT PART:** SKIP ALL FUTURE INSTANCES OF THIS DIGIT (because the backtrack1Helper recursive call above will deal with those, \n        // we simply use the next case to when NONE of this digit (from ANY index after current index) is used)\n        //This loop in conjunction with recursion helps do the following:\n        //* Assume we start with array [1, 2, 2, 3]\n        //* First, above case considers L: [1], LL: [1,2], LLL: [1,2,2], LLLL: [1,2,2,3]\n        //* The loop below makes it so that for each of the above levels/nodes, respectively, we consider the following cases after not including current element:\n        //* i.e. \n        // R: [2], LR: [1, 3], LRL: [1,3], LRR: [1], .......\n        // LLR:[1, 2, 3], LLRL: ..., LLRR: ...\n        // LLLR: [1, 1, 1, 2], ......\n        //(watch Neetcode video for full chart)\n        // RRRR: [] //Here, idx+1 == nums.Length (because last element), so the loop is skipped, and upon further recursion, we get our empty set back.\n        while(idx+1 < nums.Length && nums[idx] == nums[idx+1])\n            idx++;\n\n        //Case 2: We do not use the current element\n        backtrack1Helper(nums, idx+1, subset, res);\n        \n        return;\n    }\n}\n",
    "problemId": "subsets-ii",
    "statusDescription": "Accepted",
    "time": "0.502",
    "date": "2024-11-05T02:32:28.828Z",
    "memory": 54280,
    "stdout": "",
    "stderr": ""
}