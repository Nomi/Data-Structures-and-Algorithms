5, Compilation Error
{
    "language": "csharp",
    "code": "public class Solution {\n    public List<List<int>> SubsetsWithDup(int[] nums) {\n        //READ COMMENTS!!\n        //And watch Leetcode soln? (I had to read the written one on leetcodeio)\n        //LOOK AT THE LEETCODEIO SOLN THAT MAKES THIS ITERATIVE!!\n        \n        return backtrack1(nums);\n    }\n    \n    public List<List<int>> backtrack1(int[] nums)\n    {\n        List<List<int>> res = new(1 << nums.Length); //1<<n == 2^n //https://stackoverflow.com/a/10983207\n        \n        //IMPORTANT PART:\n        Array.Sort(nums);\n\n        backtrack1Helper(\n            nums: nums,\n            idx: 0,\n            subset: new(nums.Length),\n            res: res\n        );\n\n        return res;\n    }\n\n    //TC: O(n*2^n)\n    //SC: O(n) //subset\n    public void backtrack1Helper(int[] nums, int idx, List<int> subset, List<List<int>> res)\n    {\n        // FOR [2, 2] WE CAN HAVE SUBSETS [2, 2] (where each 2 is from different index) and [2]. Notice there's only ONE [2]. \n        //i.e. A subset may contain the duplicate values more than once, but each subset only appears once so ([2] and [2] are considered the same even if they're 2 from different indices)\n.       \n        //General note: \n        //We CAN (not must) use the binary decision tree when there's NO possibility of NOT picking for each element.\n        //The n-nary decision tree (via iteration) HELPS when the elements MUST be picked (e.g. Permutations) (or we need to stop as soon as we can't pick up an element from all or unused-only options(like in \"Combination Sum\").\n\n        if(idx == nums.Length)\n        {\n            res.Add(new(subset)); //Use copy constructor to create new reference but same data\n            return;\n        }\n\n        //Case 1: Adding current element (only if it's not a duplicate / been encountered before.)\n        subset.Add(nums[idx]);\n        backtrack1Helper(nums, idx+1, subset, res);\n        subset.RemoveAt(subset.Count-1);\n\n        //IMPORTANT PART: SKIP ALL INSTANCES OF THIS DIGIT (because the backtrack1Helper recursive call above will deal with those, \n        // we simply use the next case to when NONE of ANY of this digit is used)\n        //This loop in conjunction with recursion helps do the following:\n        //* Assume we start with array [1, 1, 1, 1, 2]\n        //* First, above case considers [1], then [1,1], then [1,1,1], then [1,1,1,1], then [1,1,1,1,2]\n        //* The loop below makes it so that for each of the above levels, respectively, we consider the following cases after not including current element:\n        //* i.e. [2], [1,2], [1,1,2], [1,1,1,2], [1,1,1,2], and then []\n        while(idx+1 < nums.Length && nums[idx] == nums[idx+1])\n            idx++;\n\n        //Case 2: We do not use the current element\n        backtrack1Helper(nums, idx+1, subset, res);\n        \n        return;\n    }\n}\n",
    "problemId": "subsets-ii",
    "statusDescription": "Compilation Error",
    "time": "0.0",
    "date": "2024-11-05T01:42:12.342Z",
    "memory": "",
    "stdout": "",
    "stderr": ""
}