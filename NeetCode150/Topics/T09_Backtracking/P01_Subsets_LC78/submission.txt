3, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    public List<List<int>> Subsets(int[] nums) {\n        // !!! IMPORTANT: READ COMMENTS OF backtrack1 !!! \n        List<List<int>> res = new(1<<nums.Length); // 1 << nums.Length == 2^nums.Length (which is number of possible subsets (because there are max n numbers and two choices for each of them: pick it or not))\n        \n        backtrack1(\n            nums: nums,\n            subset: new(nums.Length), // Min subset length = 0, Max subset length = nums.Length\n            idx: 0,\n            res: res);\n        \n        return res;\n    }\n\n\n    //HAD TO WATCH THE THEORY PART OF NEETCODE VIDEO TO SOLVE THIS!!!\n    //HAD TO PEEK AT THE C# SOLUTION ON NEETCODEIO A LITTLE TO SOLVE THIS!!!\n    public void backtrack1(int[] nums, int idx, List<int> subset, List<List<int>> res)\n    {\n        if(idx==nums.Length) //We're at the leaf node (just think about it. Watching neetcodeio video might help visualize!)\n        {\n            res.Add(new(subset)); //We use the copy constructor to avoid messing up the reference\n            return;\n        }\n\n        // int numSubsets = 1 << nums.Length; //==2^nums.Length\n        \n        // IMPORTANT NOTE: \n        // Min subset length = 0, Max subset length = nums.Length\n        // => Time complexity = n*(2^n)\n        // GIVEN THE CONSTRAINTS OF THE PROBLEMS, (since we want subsets and not just the count),\n        // THIS IS THE BEST TIME COMPLEXITY WE CAN ACHIEVE.\n        // HERE, WE USE BACKTRACKING BECAUSE IT IS MOST EFFICIENT HERE, EVEN THOUGH IT IS THE BRUTEFORCE SOLUTION.\n        // (thankfully, the constraints given to us show that the input will be small so it's fine!)\n\n        //IMPORTANT NOTE: BACKTRACKING GIVES US ONLY UNIQUE SUBSETS HERE BECAUSE THE INPUT HAS UNIQUE VALUES (no duplicates).\n\n        // CASE 2: WE DO NOT USE THE CURRENT ELEMENT\n        backtrack1(nums, idx+1, subset, res);\n\n        // CASE 2: WE USE THE CURRENT ELEMENT\n        subset.Add(nums[idx]);//Adding current to the end!\n        backtrack1(nums, idx+1,subset, res);\n        subset.RemoveAt(subset.Count - 1); //remove last element. //NEED TO REMOVE THIS BECAUSE IT WILL BE USED ON THE LEVEL ABOVE THIS (cuz it is shared via reference)\n\n        return;\n    }\n}\n",
    "problemId": "subsets",
    "statusDescription": "Accepted",
    "time": "0.47",
    "date": "2024-11-02T22:56:48.803Z",
    "memory": 54652,
    "stdout": "",
    "stderr": ""
}