6, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    public List<List<int>> CombinationSum(int[] nums, int target) \n    {\n        //:::IMPORTANT NOTES:::\n        //READ THE COMMENTS!!!\n        //WATCH THE NEETCODE VIDEO (just skim through it)\n        //CHECK NEETCODEIO SOLNS (incl. the OPTIMAL verision!)\n\n        //Check the sortedOptimalBacktrack1 approach too (aside from the normal backtrack1) \n        //backtrack1 is more important I guess? Just need to have an idea of how optimal backtrack works! (and remember it!)\n        \n        // return backtrack1(nums, target);\n        return sortedOptimalBacktrack1(nums, target);\n    }\n\n\n    \n    //Time complexity: O(2^ target) because the smallest possible number in nums is 1, so we can have at most target number of 1s as the height of our decision tree (depth of deepest branch) and for each branch there can only be 2 decisions USE or DISCARD, we get 2^target as MAX number of possible nodes in the decision tree..\n    //Space complexity: O((2^target+1)/2) // L = (N + 1)/2 where L is number of leaves for a tree with N nodes.\n    //CAN ALSO READ MORE ABOUT THIS IN NEETCODEIO SOLNS\n    public List<List<int>> backtrack1(int[] nums, int target)\n    {\n        List<List<int>> res = new();\n\n        backtrack1Helper(nums, idx: 0, target, sumThusFar: 0, subset: new(), res);\n        \n        return res;\n    }\n    //Time complexity: O(2^ target) because the smallest possible number in nums is 1, so we can have at most target number of 1s as the height of our decision tree (depth of deepest branch) and for each branch there can only be 2 decisions USE or DISCARD, we get 2^target as MAX number of possible nodes in the decision tree..\n    //Space complexity: O((2^target+1)/2) // L = (N + 1)/2 where L is number of leaves for a tree with N nodes.\n    //CAN ALSO READ MORE ABOUT THIS IN NEETCODEIO SOLNS\n    public void backtrack1Helper(int[] nums, int idx, int target, int sumThusFar, List<int> subset, List<List<int>> res)\n    {\n        //WATCH NEETCODE VIDEO!!!\n\n        if(sumThusFar>target || idx==nums.Length) //Almost forgot about the idx>nums.Length condition\n            return;\n        if(target==sumThusFar)\n        {\n            res.Add(new(subset)); // I KEEP FORGETTING TO ADD A COPY, NOT THE REFERENCE!!! (using the copy constructor)\n            return;\n        }\n\n        //Case 1: We use current element\n        subset.Add(nums[idx]);\n        backtrack1Helper(nums, idx, target, sumThusFar+nums[idx], subset, res);\n\n        //Case 2: We never use current element again\n        subset.RemoveAt(subset.Count-1);\n        backtrack1Helper(nums, idx+1, target, sumThusFar, subset, res);\n\n        return;\n    }\n\n    //THE OPTIMAL part doesn't come from the time complexity or space complexity, but from SEARCH SPACE PRUNING!\n    //Time complexity: O(2^target) because the smallest possible number in nums is 1, so we can have at most target number of 1s as the height of our decision tree (depth of deepest branch) and for each branch there can only be 2 decisions USE or DISCARD, we get 2^target as MAX number of possible nodes in the decision tree..\n    //Space complexity: O(2^target) // L = (N + 1)/2 where L is number of leaves for a tree with N nodes.\n    public List<List<int>> sortedOptimalBacktrack1(int[] nums, int target)\n    {\n        Array.Sort(nums); //default sort by ascending I think\n        List<List<int>> res = new();\n\n        sortedOptimalBacktrack1Helper(nums, idx: 0, target, sumThusFar: 0, subset: new(), res);\n        \n        return res;\n    }\n    public void sortedOptimalBacktrack1Helper(int[] nums, int idx, int target, int sumThusFar, List<int> subset, List<List<int>> res)\n    {\n        //SEARCH SPACE PRUNING!\n        //BASED ON: https://blog.seancoughlin.me/solving-leetcodes-combination-sum-problem-optimized-techniques-for-efficient-solutions#heading-optimizing-the-backtracking-solution \n        //Archived URL: https://web.archive.org/web/*/https://blog.seancoughlin.me/solving-leetcodes-combination-sum-problem-optimized-techniques-for-efficient-solutions#heading-optimizing-the-backtracking-solution\n\n        if(target==sumThusFar)\n        {\n            res.Add(new(subset)); // I KEEP FORGETTING TO ADD A COPY, NOT THE REFERENCE!!! (using the copy constructor)\n            return;\n        }\n\n        for(int i=idx; i<nums.Length;i++)\n        {\n            if(sumThusFar+nums[i] > target)\n                return; //No other branch under of this node from this point on will have the solution, so we can safely exclude/prune them from our search space!\n            //Case: We pick the number at i-th index but none before that:\n            subset.Add(nums[i]);\n            sortedOptimalBacktrack1Helper(nums, i, target, sumThusFar+nums[i], subset, res);\n            subset.RemoveAt(subset.Count-1);  //Removing from end of list is always complexity O(1)!!!\n        }\n        return;\n    }\n\n\n}\n",
    "problemId": "combination-target-sum",
    "statusDescription": "Accepted",
    "time": "0.5",
    "date": "2024-11-03T02:12:35.199Z",
    "memory": 54384,
    "stdout": "",
    "stderr": ""
}