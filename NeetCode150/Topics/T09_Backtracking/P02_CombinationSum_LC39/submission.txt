3, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    public List<List<int>> CombinationSum(int[] nums, int target) \n    {\n        //:::IMPORTANT NOTES:::\n        //READ THE COMMENTS!!!\n        //WATCH THE NEETCODE VIDEO (just skim through it)\n        //CHECK NEETCODEIO SOLNS (incl. the OPTIMAL verision!)\n        return backtrack1(nums, target);\n    }\n\n\n    \n    //Time complexity: O(2^ target) because the smallest possible number in nums is 1, so we can have at most target number of 1s as the height of our decision tree (depth of deepest branch) and for each branch there can only be 2 decisions USE or DISCARD, we get 2^target as MAX number of possible nodes in the decision tree..\n    //Space complexity: O((2^target+1)/2) // L = (N + 1)/2 where L is number of leaves for a tree with N nodes.\n    //CAN ALSO READ MORE ABOUT THIS IN NEETCODEIO SOLNS\n    public List<List<int>> backtrack1(int[] nums, int target)\n    {\n        List<List<int>> res = new();\n\n        //\n\n        backtrack1Helper(nums, idx: 0, target, sumThusFar: 0, subset: new(), res);\n        \n        return res;\n    }\n    //Time complexity: O(2^ target) because the smallest possible number in nums is 1, so we can have at most target number of 1s as the height of our decision tree (depth of deepest branch) and for each branch there can only be 2 decisions USE or DISCARD, we get 2^target as MAX number of possible nodes in the decision tree..\n    //Space complexity: O((2^target+1)/2) // L = (N + 1)/2 where L is number of leaves for a tree with N nodes.\n    //CAN ALSO READ MORE ABOUT THIS IN NEETCODEIO SOLNS\n    public void backtrack1Helper(int[] nums, int idx, int target, int sumThusFar, List<int> subset, List<List<int>> res)\n    {\n        //WATCH NEETCODE VIDEO!!!\n\n        if(sumThusFar>target || idx==nums.Length) //Almost forgot about the idx>nums.Length condition\n            return;\n        if(target==sumThusFar)\n        {\n            res.Add(new(subset)); // I KEEP FORGETTING TO ADD A COPY, NOT THE REFERENCE!!! (using the copy constructor)\n            return;\n        }\n\n        //Case 1: We use current element\n        subset.Add(nums[idx]);\n        backtrack1Helper(nums, idx, target, sumThusFar+nums[idx], subset, res);\n\n        //Case 2: We never use current element again\n        subset.RemoveAt(subset.Count-1);\n        backtrack1Helper(nums, idx+1, target, sumThusFar, subset, res);\n\n        return;\n    }\n}\n",
    "problemId": "combination-target-sum",
    "statusDescription": "Accepted",
    "time": "0.488",
    "date": "2024-11-03T01:37:37.651Z",
    "memory": 54636,
    "stdout": "",
    "stderr": ""
}