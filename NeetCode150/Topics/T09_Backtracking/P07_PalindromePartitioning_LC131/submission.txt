6, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    //**NOTE:** WATCH TakeUForward's L17. Palindrome Partitioning video to learn how this works. (4:00 to 14:00, can watch most of it on 2x).\n    //** {OR CHECK THE EXAMPLE RUN AT THE END OF Backtrack1's dfs funtion} **\n\n    //HAD TO WATCH THE VIDEO TO DO IT! STILL DON'T FULLY UNDERSTAND\n    //this helps: https://www.geeksforgeeks.org/given-a-string-print-all-possible-palindromic-partition/\n    \n    public List<List<string>> Partition(string s) {\n        //** GENERAL TIPS: **\n        //SIZE OF INPUT IS A GREAT CLARIFYING QUESTION! (and other constraints)\n        //ALSO CONFIRM EXPECTED TIME COMPLEXITY \n        //(say your solution, say the complexity and ask them if that's what they're looking for or I should think more)\n        \n        //Notice that no matter the string given (as long as it is not \"\"), you can partition it in this because at least you will have each individual character as a palindrome.\n        return (new Backtrack1(s)).Solve();\n    }\n}\n\npublic class Backtrack1\n{\n    List<List<string>> res; //all partitions\n    List<string> part; //current partition\n    //This solution MIGHT POSSIBLY improve by using ReadOnlySpan<Char> but the result and partitions contain the strings themselves\n    string s;\n    public Backtrack1(string s)\n    {\n        res = new(1<<s.Length); //O(2^n) [where n==s.Length]\n        part = new(s.Length); //O(n) because min partition is each element by itself\n        this.s = s;\n    }\n    public List<List<string>> Solve()\n    {\n        dfs(0);\n        return res;\n    } \n    public void dfs(int idx)\n    {\n        if(idx==s.Length)\n        {\n            res.Add(new(part));\n            return;\n        }\n\n        for(int j = idx;j<s.Length;j++) //is every possible substring (starting at idx) a palindrome //Go through through all the substrings to find all the ones that can be in THIS partition. e.g. For aabb, on first level: a|abb, aa|bb. aabb| but NOTaab|b because the chosen partition doesn't create a palindrome on the left.\n        {\n            if(isPalindrome(s, idx, j))\n            {\n                part.Add(s[idx..(j+1)]);\n                dfs(j+1);       //dfs is in this loop because all divisions in a partition need to be palindromes, so any set that contains this substring would not fulfil the criteria so no need to go any further and we can stop/prune the search off.\n                part.RemoveAt(part.Count-1);\n            }\n        }\n\n        //Example run: ([*] means * is a valid, complete parition we can add to output.)\n        //For aabb, on first level: a|abb, aa|bb, but NOTaab|b ORaabb because the chosen partition doesn't create a palindrome on the left.\n        //On second level: a|a|bb, aa|b|b, [aa|bb|].\n        //On third level:  a|a|b|b, [a|a|bb|], [aa|b|b|]\n        //On fourth level: [a|a|b|b|].\n        //Therefore, the result = [a|a|b|b|, a|a|bb|, aa|b|b|, aa|bb|].\n    }\n\n    public bool isPalindrome(string s, int i, int j)\n    {\n        for(;i<j;i++, j--)\n        {\n            if(s[i]!=s[j])\n                return false;\n        }\n        return true;\n    }\n}\n",
    "problemId": "palindrome-partitioning",
    "statusDescription": "Accepted",
    "time": "0.657",
    "date": "2024-11-07T02:02:12.323Z",
    "memory": 54808,
    "stdout": "",
    "stderr": ""
}