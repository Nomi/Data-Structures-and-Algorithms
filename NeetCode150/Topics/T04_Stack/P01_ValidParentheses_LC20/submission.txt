6, Accepted
{
    "date": "2024-09-16T22:17:03.488Z",
    "statusDescription": "Accepted",
    "code": "public class Solution {\n    public bool IsValid(string s) {\n        //USE NEETCODE BASED ATTEMPT FOR ACTUAL REFERENCE!!!\n        // return attempt1(s);\n\n        //USE THIS FOR ACTUAL REFERENCE:\n        return NeetCodeBasedSoln(s); // (also, uses the nifty trick of using the HashMap closingToOpen instead of openingToClosing)\n    }\n    \n    //USE THIS FOR ACTUAL REFERENCE:\n    // (also, uses the nifty trick of using the HashMap\n    // closingToOpen instead of openingToClosing)\n    public bool NeetCodeBasedSoln(string s) \n    {\n        Stack<char> stack = new();\n        Dictionary<char,char> closeToOpen = new(){\n            {')','('},\n            {'}','{'},\n            {']','['}};\n\n        foreach(char c in s)\n        {\n            if(!closeToOpen.ContainsKey(c)) //not closing bracket //I guess we don't need to consider wrong input otherwise the hashmap would break on using them as key if not checked for containing it as key\n            {\n                //by if: it is not a closing bracket\n                stack.Push(c);\n            }\n            else if(stack.Count==0 || stack.Pop() != closeToOpen[c])\n            {\n                //by else: it is a closing bracket\n                //by if: \n                //      1. there were no opening brackets before this.\n                //      2. the last opening bracket was of a different type than this closing bracket.\n                return false;\n            }\n        }\n        return (0==stack.Count);\n    }\n\n    public bool attempt1(string s) //USE NEETCODE BASED ATTEMPT FOR ACTUAL REFERENCE\n    {\n        Stack<char> stack = new();\n        Dictionary<char,char> openToClose = new(){\n            {'(',')'},\n            {'{','}'},\n            {'[',']'}};\n        HashSet<char> close = new(){')','}',']'};\n\n        for(int i=0;i<s.Length;i++)\n        {\n            char c = s[i];\n            if(stack.Count==0||openToClose.ContainsKey(c))\n            {\n                if(close.Contains(c))\n                    return false;\n                stack.Push(c);\n                continue;\n            }\n            char lastChar = stack.Pop();\n            if(!openToClose.ContainsKey(lastChar)) //I guess we don't need this and we can assume it input will always contain only the provided chars???\n                return false;\n            if(c!=openToClose[lastChar])\n                return false;\n        }\n        if(stack.Count>0)\n            return false;\n        return true;\n    }\n}\n",
    "memory": 60312,
    "stdout": "",
    "language": "csharp",
    "time": "1.01",
    "problemId": "validate-parentheses",
    "stderr": ""
}