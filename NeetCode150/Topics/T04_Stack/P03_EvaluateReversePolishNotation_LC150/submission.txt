7, Accepted
{
    "date": "2024-09-16T23:05:30.899Z",
    "statusDescription": "Accepted",
    "code": "public class Solution {\n    public int EvalRPN(string[] tokens) {\n        //are we guaranteed input is correct?\n        return attempt1(tokens);\n    }\n\n    static readonly Dictionary<string, Func<int, int, int>> operations = new(){\n        { \"+\", (x, y) => x + y },\n        { \"*\", (x, y) => x * y },\n        { \"-\", (x, y) => x - y },\n        { \"/\", (x, y) => (int)((double)x / y) } //GOTTA REMEMBER!?!?!\n    };\n\n    public int attempt1(string[] tokens)\n    {\n        Stack<string> stk = new();\n        foreach(string s in tokens) //Currently assuming the input is always correct.\n        {\n            if(int.TryParse(s, out int num))\n            {\n                stk.Push(s);\n                continue;\n            }\n            //else:\n            int.TryParse(stk.Pop(), out int b);//later number is on top of stack!\n            int.TryParse(stk.Pop(), out int a);//earlier number will be deeper in the stack, of course!\n            //[Important] the above order is because for [a,b,'-'],\n            //the stack looks like [b,a] when we encounter '-', \n            //where top is on the left. Therefore, to get a-b as \n            //we want, we pop to get b first, then pop to get\n            //a first and b second.\n            stk.Push(operations[s](a,b).ToString());\n            // Console.WriteLine($\"{a} {s} {b} = {stk.Peek()}\");\n        }\n        int.TryParse(stk.Pop(), out int res);\n        return res;\n    }\n}\n",
    "memory": 90900,
    "stdout": "",
    "language": "csharp",
    "time": "0.824",
    "problemId": "evaluate-reverse-polish-notation",
    "stderr": ""
}