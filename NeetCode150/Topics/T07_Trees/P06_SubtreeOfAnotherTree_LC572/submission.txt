3, Accepted
{
    "date": "2024-10-03T22:33:15.701Z",
    "statusDescription": "Accepted",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {    \n    public bool IsSubtree(TreeNode root, TreeNode subRoot) {\n        //USE THE NEETCODE SOLN AS REFERENCE!!! (compare to mine?)\n        //Time Complexity is of course O(mainTreeLen * subTreeLen)\n\n        // return Attempt1_MyOwn.rec1(root, subRoot);\n        return NeetCodeIoBasedSoln.IsSubtree(root, subRoot);\n    }\n}\n\npublic static class NeetCodeIoBasedSoln\n{\n    public static bool IsSubtree(TreeNode root, TreeNode subRoot) { //Recursive function\n        //EDGECASE - COULDN'T HAVE THOUGHT OF THIS: EMPTY TREE IS SUBTREE OF EVERY TREE.\n        if (subRoot == null)\n            return true;\n        //ELSE (because of the return in the if)\n        if (root == null) //we know root is not the same as subRoot when its null because of the if above.\n            return false;\n        //ELSE (because of the return in the if)\n        if (SameTree(root, subRoot))  //recursive function used inside another recursive function!\n        {\n            return true;\n        }\n        //ELSE (because of the return in the if)\n        return IsSubtree(root.left, subRoot) || IsSubtree(root.right, subRoot);\n    }\n\n    public static bool SameTree(TreeNode root, TreeNode subRoot) { //Recursive function\n        //My attempt for this part was a little bit better so I used that!\n        if(root == null && subRoot == null)\n            return true;\n        \n        if(root?.val != subRoot?.val)\n            return false;\n\n        return SameTree(root.left, subRoot.left) && SameTree(root.right, subRoot.right);\n    }\n}\n\npublic static class Attempt1_MyOwn\n{\n    public static bool rec1(TreeNode root, TreeNode subRoot) \n    {\n        bool found = false;\n        if(root?.val==subRoot?.val)\n            found = recEqCheck1(root, subRoot); //recursive function used inside another recursive function!\n        else if(root==null) //above condition implies subRoot != null while here root is. Therefore, we'll be unable to find the subtree from here.\n            return false;\n        if(found)\n            return true;\n        else\n        {\n            if(rec1(root?.left, subRoot)||rec1(root?.right, subRoot))\n                return true;\n        }\n        return false;\n    }\n    public static bool recEqCheck1(TreeNode root, TreeNode subRoot) //Recursive function\n    {\n        // Console.WriteLine($\"{root?.val}, {subRoot?.val}\");\n        if(root == null && subRoot == null)\n            return true;\n        \n        if(root?.val != subRoot?.val)\n            return false;\n\n        return recEqCheck1(root.left, subRoot.left) && recEqCheck1(root.right, subRoot.right);\n    }\n}\n",
    "memory": 53928,
    "stdout": "",
    "language": "csharp",
    "time": "0.763",
    "problemId": "subtree-of-a-binary-tree",
    "stderr": ""
}