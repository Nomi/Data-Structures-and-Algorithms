2, Wrong Answer
{
    "date": "2024-10-07T22:15:59.866Z",
    "statusDescription": "Wrong Answer",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public List<int> RightSideView(TreeNode root) {\n        // IMPORTANT!! BE CAREFUL!!\n        // I DID NOT THINK IF THE TREE COULD BE LARGER TOWARDS THE LEFT SIDE (until I ran into a breaking test case)!!\n        return itr1BFS(root);\n    }\n\n    public List<int> itr1BFS(TreeNode root)\n    {\n        List<int> res = new();\n        Queue<TreeNode> q = new();\n        q.Enqueue(root);\n\n        while(q.Count>0)\n        {\n            int lastElem = -1;\n            for(int i=0, len = q.Count; i<len; i++)\n            {\n                var cur =  q.Dequeue();\n                lastElem = cur.val;\n                if(cur.left!=null) q.Enqueue(cur.left);\n                if(cur.right!=null) q.Enqueue(cur.right);\n            }\n            res.Add(lastElem);\n        }\n\n        return res;\n    }\n    \n    //THE FOLLOWING IS WRONG BECAUSE A BRANCH ON THE LEFT CAN BE LONGER THAN THE RIGHT MOST BRANCH FROM THE ROOT!!!\n    // public List<int> itr1DfsRHS(TreeNode root)\n    // {\n    //     List<int> res = new();\n    //     while(root!=null)\n    //     {\n    //         res.Add(root.val);\n    //         root = root.right??root.left;\n    //     }\n    //     return res;\n    // }\n}\n",
    "memory": 54196,
    "stdout": "",
    "language": "csharp",
    "time": "0.809",
    "problemId": "binary-tree-right-side-view",
    "stderr": ""
}