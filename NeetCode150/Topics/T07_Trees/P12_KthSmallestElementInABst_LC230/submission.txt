2, Accepted
{
    "date": "2024-10-08T22:18:00.167Z",
    "statusDescription": "Accepted",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public int KthSmallest(TreeNode root, int k) {\n        //READ COMMENTS OF rec1Dfs!!!!\n        nodesTraversedInOrder = 0;\n        return rec1Dfs(root, k);\n    }\n\n    //Came up with the solution on my own but faced a few minor hiccups that I resolved by myself.\n    int nodesTraversedInOrder;\n    public int rec1Dfs(TreeNode root, int k)\n    {\n        if(root == null)\n            return -404;\n        \n        var left = rec1Dfs(root.left, k);\n        if(left!=-404)\n            return left;\n        \n        //ELSE we still need to look at this node and, if needed, its right subtree\n        ///The following comment is DEPRECATED/invalid due to changes abovee. // if(left == -404) //Clearly we don't need to check for this because if we don't then even if we find the node, we will end up with the nodesTraversedInOrder stuck at =k and as such every node after that as we traverse back up to the beginning of the recursive stack will overwrite the correct result in our program.\n        nodesTraversedInOrder++;\n        if(nodesTraversedInOrder == k) //Found k-th smallest element.\n            return root.val;\n            \n        var right = rec1Dfs(root.right, k);\n        return right; //right will be -404 if we don't actually find it in this branch, so we continue our search in that case.\n    }\n}\n",
    "memory": 53472,
    "stdout": "",
    "language": "csharp",
    "time": "0.813",
    "problemId": "kth-smallest-integer-in-bst",
    "stderr": ""
}