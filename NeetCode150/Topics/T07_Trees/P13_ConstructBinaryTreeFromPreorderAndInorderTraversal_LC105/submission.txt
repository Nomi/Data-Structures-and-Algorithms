2, Accepted
{
    "date": "2024-10-09T23:04:27.762Z",
    "statusDescription": "Accepted",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public TreeNode BuildTree(int[] preorder, int[] inorder) {\n        //Since we are not making changes to the values of the sub-arrays, we can use the ArraySegment wrapper (otherwise it would change the original array as well).\n        ReadOnlySpan<int> preo = new(preorder);\n        ReadOnlySpan<int> ino = new(inorder);\n        //ARRAY SLICING IN C#: https://code-maze.com/csharp-array-slicing/\n        //SHOULD HAVE USED ReadOnlySpan!!\n        return rec1(preo, ino);\n    }\n\n    public TreeNode rec1(ReadOnlySpan<int> preorder, ReadOnlySpan<int> inorder)\n    {\n        //ACCORDING TO THE NEETCODE VIDEO, WE NEED THE FOLLOWING:   (WATCH THE NEETCODE VIDEO!!!)\n        //Note that it's given every value in tree is unique.\n        //Fact 1: First value in preorder traversal is always the root. \n        //        This can be done for each subtree after that (as long as we disregard/remove the prevcious root).\n        //Fact 2: Every value to the left of an elemen in the in-order traversal array is on the left sub tree \n        //        and every element after that goes in right subtree. (we got through the tree inorder (left to right.))\n        \n        if(preorder.IsEmpty || inorder.IsEmpty)\n            return null;\n\n        var curRoot = new TreeNode(preorder[0]);\n        Console.WriteLine(preorder[0]);\n        int curPosInInorder = inorder.IndexOf(curRoot.val);\n\n        // try{\n        curRoot.left = rec1(preorder[1..(1+curPosInInorder)], inorder[..curPosInInorder]); //rec1(preorder.Slice(1,1+curPosInOrder), inorder.Slice(0, curPosInOrder));\n        //NOTES FOR THE LINE DIRECTLY ABOVE THIS COMMENT:\n        //??? (1+curPosInOrder) because the second parameter is length and we want to include the same number of elements in inorder as we do in preorder (i.) We start from 1 because we don't want it as we're done with creating it.\n        curRoot.right = rec1(preorder[(1+curPosInInorder)..], inorder[(1+curPosInInorder)..]); //rec1(preorder.Slice(1+curPosInOrder));\n        // }\n        // catch(ArgumentOutOfRangeException e)\n        // {\n        //     Console.WriteLine(e.ToString());\n        //     Console.WriteLine($\"pL : {preorder.Length}, iL : {inorder.Length}, cPII : {curPosInInorder}\");\n        // }\n        return curRoot;\n     }\n\n    public static int GetIndexOf(ArraySegment<int> arraySegment, int target)\n    {\n        int i=0;\n        while(true)\n        {\n            if(arraySegment[i]==target)\n                return i;\n            i++;\n        }\n    }\n}\n\n\n//## Thinking out loud: \n//           1\n//          /\n//         2\n//        / \\\n//       3   5\n//      /\n//     4\n// Preorder: 1, 2, 3, 4, 5\n// Inorder:  4, 3, 2, 5, 1\n//\n// Clearly, when we reach the end of the list, in preorder, the element at the left-most end will be in the beginning.\n// That is to say, we can know when a tree ends when we reach the element at the beginning.\n// Also, any unseen nodes from then on, are on the right node.",
    "memory": 51552,
    "stdout": "",
    "language": "csharp",
    "time": "0.761",
    "problemId": "binary-tree-from-preorder-and-inorder-traversal",
    "stderr": ""
}