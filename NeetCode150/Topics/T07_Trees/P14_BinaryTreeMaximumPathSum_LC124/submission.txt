4, Accepted
{
    "date": "2024-10-14T23:12:18.472Z",
    "statusDescription": "Accepted",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public int MaxPathSum(TreeNode root) {\n        //YOOOOO!!! DID IT BY MYSELF WITHIN 20 MINTUES (no outside help AT ALL)!!!!\n        rec1(root);\n        return maxSum;\n    }\n\n    int maxSum = int.MinValue; //The FOLLOWING comment is DEPRECATED BECAUSE WHEN READING THE PROBLEM CAREFULLY, YOU'LL SEE THAT YOU CAN'T NOT SELECT! I only realized after failing a test case.://because even if every value is negative, we can select an 0 nodes to get an empty path with the sum 0.\n    public (int lSum, int rSum) rec1(TreeNode root)\n    {\n        //Clearly we need to do this postorder?\n        if(root == null)\n            return (0,0);\n        \n        int currVal = root.val;\n\n        (int lLSum, int lRSum) = rec1(root.left);\n        var (rLSum, rRSum) = rec1(root.right);\n        \n        int lSum = (int) Math.Max(lLSum, lRSum);\n        if(lSum<0) lSum = 0;\n        int rSum = (int) Math.Max(rLSum, rRSum);\n        if(rSum<0) rSum = 0;\n\n        // int biggerSum = lSum > rSum ? lSum : rSum;\n        // biggerSum += currVal;\n        int maxSumAtCurrNode = lSum+rSum+currVal; //Notice that NONE of these can be negative due to the if conditions above where we set them to 0 in case they're negative (i.e. we ignore the branch(es) that is(are) not helpful).\n        //We make sure to add the currVal because we have already considered each branch without this node already.\n        //Also, we would need to include the current one to connect the two branches to form a path.\n\n        // Console.WriteLine($\"MS= {maxSum}, CV= {currVal}, MSACN = {maxSumAtCurrNode}\"); //BS= {biggerSum},\n        if(maxSum<maxSumAtCurrNode)\n            maxSum = maxSumAtCurrNode;\n        \n        return ((lSum+currVal), (rSum+currVal));\n    }\n}\n",
    "memory": 51332,
    "stdout": "",
    "language": "csharp",
    "time": "0.747",
    "problemId": "binary-tree-maximum-path-sum",
    "stderr": ""
}