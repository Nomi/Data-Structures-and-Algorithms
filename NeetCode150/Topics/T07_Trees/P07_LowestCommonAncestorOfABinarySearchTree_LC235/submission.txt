1, Accepted
{
    "date": "2024-10-07T19:52:14.600Z",
    "statusDescription": "Accepted",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        var bigger = p.val>=q.val ? p : q;\n        var smaller = p.val>=q.val ? q : p;\n        return rec1(root, smaller, bigger);\n    }\n\n    public TreeNode rec1(TreeNode root, TreeNode smaller, TreeNode bigger)\n    {\n        Console.WriteLine($\"{root?.val} : {smaller.val}, {bigger.val}\");\n        if(root==null) //this node cannot be ancestor of anything\n            return null;\n        if(root.val>bigger.val)\n            return rec1(root.left, smaller, bigger);\n        if(root.val<smaller.val)\n            return rec1(root.right, smaller, bigger);\n\n        // == \n        //Notice how because of the conditions above we will only ever get here when in the following cases:\n        //\n        //1. When `root`'s value is between smaller and bigger and as such,\n        //this is where the paths diverge (smaller on left and bigger on right).\n        //Therefore, this point would be the LOWEST common ancestor.\n        //\n        //2. If the above condition is untrue, this means that the `root` is either the `smaller` or `bigger` node.\n        // and since we haven't found the other one yet and it is guaranteed [clarification question???] that\n        // both the values exist in there, we can be sure that this is the lowest common ancestor because this element won't be anywhere after here.\n        return root;\n\n        // //Here, we're guaranteed `root` is AN ancestor, but not necessarily the lowest.\n        // // if(root.val>=smaller.val && root.val<=bigger.val) //<= and >= because the nodes themselves can be the ancestor.\n        // // {\n        //     return rec1(root.left, smaller, bigger) ?? rec1(root.right, smaller, bigger) ?? root; //Either the lowest common ancestor is lower than this to EITHER left OR right (because of definiton of BST) OR this node is the lowest common ancestor.\n        // // }            \n    }\n}\n",
    "memory": 53224,
    "stdout": "",
    "language": "csharp",
    "time": "0.82",
    "problemId": "lowest-common-ancestor-in-binary-search-tree",
    "stderr": ""
}