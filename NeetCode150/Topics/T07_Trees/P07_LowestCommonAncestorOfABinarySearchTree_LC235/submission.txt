7, Accepted
{
    "date": "2024-10-07T20:11:53.207Z",
    "statusDescription": "Accepted",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\n        //IMPORTANT! USE NEETCODEIO ITERATIVE SOLUTION \n        // BECAUSE IT IS BETTER DUE TO SAME TIME COMPLEXITY BUT O(1) SPACE COMPLEXITY \n        // (recursive has O(log(n) space complexity)!!!!\n        //READ THE COMMENTS FOR rec1 (and rec1Helper) \n        // return rec1(root, p, q);\n        return itr1_NeetCodeBasedSoln(root, p, q);\n    }\n\n    public TreeNode itr1_NeetCodeBasedSoln(TreeNode root, TreeNode p, TreeNode q) //Should modify to bigger and smaller precalculated like in rec1 to simplify conditions!\n    {\n        while(true)\n        {\n            if(root.val < p.val && root.val < q.val) //Checking both here because we don't know which one is bigger or smaller, but we could modify it that way (like in the recursive solution!)\n                root = root.right;\n            else if (root.val > p.val && root.val > q.val)\n                root = root.left;\n            else\n                return root; // Check comments in rec1Helper to check why this works!\n        }\n    }\n    //TC: O(log(n))\n    //SC: O(log(n))\n    public TreeNode rec1(TreeNode root, TreeNode p, TreeNode q)\n    {\n        var bigger = p.val>=q.val ? p : q;\n        var smaller = p.val>=q.val ? q : p;\n        return rec1Helper(root, smaller, bigger);\n    }\n    public TreeNode rec1Helper(TreeNode root, TreeNode smaller, TreeNode bigger)\n    {\n        // Console.WriteLine($\"{root?.val} : {smaller.val}, {bigger.val}\");\n\n        if(root.val>bigger.val)\n            return rec1Helper(root.left, smaller, bigger);\n        if(root.val<smaller.val)\n            return rec1Helper(root.right, smaller, bigger);\n\n        //IF root.val >= smaller.val && root.val <= bigger.val (because of above if conditions) \n        \n        //Notice how because of the conditions above we will only ever get here when in the following cases:\n        //\n        //1. When `root`'s value is between smaller and bigger and as such,\n        //this is where the paths diverge (smaller on left and bigger on right).\n        //Therefore, this point would be the LOWEST common ancestor.\n        //\n        //2. If the above condition is untrue, this means that the `root` is either the `smaller` or `bigger` node.\n        // and since we haven't found the other one yet and it is guaranteed [clarification question???] that\n        // both the values exist in there, we can be sure that this is the lowest common ancestor because this element won't be anywhere after here.\n        return root;\n    }\n}\n",
    "memory": 53800,
    "stdout": "",
    "language": "csharp",
    "time": "0.739",
    "problemId": "lowest-common-ancestor-in-binary-search-tree",
    "stderr": ""
}