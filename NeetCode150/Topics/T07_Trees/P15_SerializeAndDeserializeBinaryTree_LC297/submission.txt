1, Accepted
{
    "language": "csharp",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Codec {\n    //READ MY COMMENTS FROM Attempt1 !!! (Both the notes outside functions and the comments inside the functions!!)\n    // Encodes a tree to a single string.\n    public string Serialize(TreeNode root) {\n        return (new Attempt1()).Serialize(root);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode Deserialize(string data) {\n        return (new Attempt1()).Deserialize(data);\n    }\n}\n\n\npublic class Attempt1\n{\n    //NOTES: \n    //1. Partially based on NEETCODEIO, mostly done by myself\n    //2. VERY EASY ONCE YOU KNOW THE TRICK, SORT OF (there's just some things to consider maybe??)\n    //3. COMPARE SOLUTION WITH NEETCODEIO!\n    //4. I HAD WATCHED NEETCODE'S VIDEO (the approach part only, not the code) A FEW DAYS AGO WHEN I WAS CONFUSED ON WHAT TO DO.\n    //5. WATCH THE APPROACH PART OF NEETCODE's VIDEO???\n    //6. Check/read_through the solution once?\n\n    List<string> listElemStr;\n\n    // Encodes a tree to a single string.\n    public string Serialize(TreeNode root) \n    {\n        listElemStr = new();\n        dfsSerialize(root);\n        return string.Join(',', listElemStr);\n    }\n    void dfsSerialize(TreeNode root)\n    {\n        if(root==null)\n        {\n            listElemStr.Add(\"N\");\n            return;\n        }\n        listElemStr.Add(root.val.ToString());\n        dfsSerialize(root.left);\n        dfsSerialize(root.right);\n        return;\n    }\n\n    // Decodes your encoded data to tree.\n    int curIdx;\n    public TreeNode Deserialize(string serializedTree) \n    {\n        curIdx = 0;\n        listElemStr = serializedTree.Split(',').ToList(); //Can get rid of this ToList if we follow how NeetCodeIo does it!\n        return dfsDeserialize();\n    }\n    public TreeNode dfsDeserialize() \n    {\n        //due to our serialization covering every node and every leaf (and every null \"child\" of the leaf) \n        //the recursion will EXACTLY, COMPLETELY run through the whole array (not less nor more).\n\n        if(listElemStr[curIdx]==\"N\")\n        {\n            curIdx++;\n            return null;\n        }\n\n        var curNode = new TreeNode(int.Parse(listElemStr[curIdx]));\n        curIdx++;\n        curNode.left = dfsDeserialize();\n        curNode.right = dfsDeserialize();\n\n        return curNode;\n    }   \n}",
    "problemId": "serialize-and-deserialize-binary-tree",
    "statusDescription": "Accepted",
    "time": "0.744",
    "date": "2024-10-17T23:35:18.728Z",
    "memory": 54244,
    "stdout": "",
    "stderr": ""
}