2, Accepted
{
    "language": "csharp",
    "code": "public class Twitter {\n    ITwitter backend;\n    public Twitter() {\n        backend = new attempt1();\n    }\n    \n    public void PostTweet(int userId, int tweetId) {\n        backend.PostTweet(userId, tweetId);\n    }\n    \n    public List<int> GetNewsFeed(int userId) {\n        return backend.GetNewsFeed(userId);\n    }\n    \n    public void Follow(int followerId, int followeeId) {\n        backend.Follow(followerId, followeeId);\n    }\n    \n    public void Unfollow(int followerId, int followeeId) {\n        backend.Unfollow(followerId, followeeId);\n    }\n}\n\npublic interface ITwitter \n{\n    public void PostTweet(int userId, int tweetId);\n    \n    public List<int> GetNewsFeed(int userId);\n    \n    public void Follow(int followerId, int followeeId);\n    \n    public void Unfollow(int followerId, int followeeId);\n}\n\n\npublic class attempt1 : ITwitter\n{\n    Dictionary<int, HashSet<int>> followMap; //EDGE CASE: INITIALLY HAD List<int> for followed users because I didn't consider the possiblity of keeping followers unique (and constant time unfollow)\n    Dictionary<int, List<(int content, int time)>> tweetMap;\n    int time;\n    const int MAX_TWEETS_IN_FEED = 10;\n\n    public attempt1() {\n        followMap = new();\n        tweetMap = new();\n        time = 0; \n    }\n    \n    public void PostTweet(int userId, int tweetId) {\n        Follow(userId, userId);//this is to make sure a user sees tweets they made //HAD MISSED THIS EARLIER (didn't read description properly I guess?)\n        time++;\n        tweetMap.TryAdd(userId, new List<(int,int)>(){});\n        tweetMap[userId].Add((tweetId, time));\n    }\n    \n    public List<int> GetNewsFeed(int userId) {         \n        if(!followMap.ContainsKey(userId))\n            return new(){};\n        \n        PriorityQueue<(int content, int time),int> minHeap = new(MAX_TWEETS_IN_FEED);\n        foreach(int followeeId in followMap[userId])\n        {\n            if(!tweetMap.ContainsKey(followeeId))\n                continue;\n            foreach(var tweet in tweetMap[followeeId])\n            {\n                if(minHeap.Count<MAX_TWEETS_IN_FEED)\n                {\n                    minHeap.Enqueue(tweet, tweet.time);\n                }\n                else if(minHeap.Peek().time<tweet.time)\n                {\n                    minHeap.Dequeue();\n                    minHeap.Enqueue(tweet, tweet.time);\n                }\n            }\n        }\n\n        //IMPORTANT NOTE!!!!\n        //MISSED THE LINE : \"Tweets IDs should be ordered from most recent to least recent.\" earlier.\n        //If the input wasn't so small, MAYBE? we should have used SortedSet (like in NeetCodeIo C# example) to avoid making a redundant int[] which gets copied to create a List<int> to return.\n        int[] res = new int[minHeap.Count];\n        while(minHeap.Count>0)\n        {\n            res[minHeap.Count-1] = minHeap.Dequeue().content;\n        }\n        return new List<int>(res);\n    }\n    \n    public void Follow(int followerId, int followeeId) {\n        followMap.TryAdd(followerId, new HashSet<int>());\n        followMap[followerId].Add(followeeId);\n    }\n    \n    public void Unfollow(int followerId, int followeeId) {\n        if(followerId==followeeId) //FORGOT ABOUTT THIS EDGE CASE AS WELL UNTIL LATE INTO THE GAME!! (maybe because I added the functionality to follow the user themselves autmatically just recently / a minute ago as well)\n            return;\n        if(followMap.ContainsKey(followerId)) //forgot about checking for this edge case earlier\n            followMap[followerId].Remove(followeeId);\n    }\n}\n",
    "problemId": "design-twitter-feed",
    "statusDescription": "Accepted",
    "time": "0.67",
    "date": "2024-10-23T22:58:50.709Z",
    "memory": 53648,
    "stdout": "",
    "stderr": ""
}