4, Accepted
{
    "language": "csharp",
    "code": "public class MedianFinder {\n    IMedianFinder solver;\n    public MedianFinder() {\n        //READ THE COMMENTS OF THE attempt1 CLASS!!!\n        solver = new attempt1();\n    }\n    \n    public void AddNum(int num) {\n        solver.AddNum(num);\n    }\n    \n    public double FindMedian() {\n        return solver.FindMedian();\n    }\n}\n\n\npublic interface IMedianFinder { \n    public void AddNum(int num);\n    \n    public double FindMedian();\n}\n\npublic class attempt1 : IMedianFinder\n{   \n    //Space Complexity: O(N)\n    PriorityQueue<int,int> leftHalf; //maxheap\n    PriorityQueue<int,int> rightHalf; //minheap\n    \n    public attempt1()\n    {\n        leftHalf = new();\n        rightHalf = new();\n        // //Filling with dummy values to make our checks while adding easier (not checking if either are empty)\n        // leftHalf.Enqueue(int.MinValue, int.MaxValue); //priority = int.MaxValue cuz priority queue has smalles priorty first (and -int.MinValue overflows)\n        // rightHalf.Enqueue(int.MaxValue, int.MaxValue); //priority = int.MaxValue cuz priority queue has smalles priorty first\n    }\n\n    //IMPORTANT!!! TAKE A LOOK AT THIS FUNCTION (and how it's done)!!! (I had to take a peek at the NeetCodeIo solution initally a little to get how its done)\n    //Time Complexity: O(nlog(n))\n    public void AddNum(int num) //THIS FUNCTION REQUIRED ME TO TAKE A BRIEF LOOK AT THE NEETCODEIO SOLN!\n    {\n        if(rightHalf.Count != 0 && num > rightHalf.Peek()) // !=0 because we try to insert to left first, arbitrarily chosen. Could do right too.\n            rightHalf.Enqueue(num, num); //minheap so we use num as prio\n        else\n            leftHalf.Enqueue(num, -num); //maxheap so we use -num as prio\n\n        //Make sure the 'halves' are balanced:\n        if(leftHalf.Count > rightHalf.Count+1) //+1 for when queue has odd number of elements\n        {\n            int largestOnLeft = leftHalf.Dequeue();\n            rightHalf.Enqueue(largestOnLeft, largestOnLeft); //minheap so we keep smallestOnRight as priority\n        }\n        else if(rightHalf.Count > leftHalf.Count+1) //+1 for when queue has odd number of elements\n        {\n            int smallestOnRight = rightHalf.Dequeue();\n            leftHalf.Enqueue(smallestOnRight, -smallestOnRight); //maxheap so we use (-largestOnLeft) as priority\n        }\n    }\n\n    //Time Complexity: O(1)\n    public double FindMedian()\n    {\n        //odd number of numbers:\n        if(leftHalf.Count!=rightHalf.Count) \n            return leftHalf.Count>rightHalf.Count ? leftHalf.Peek() : rightHalf.Peek();\n        \n        //even number of numbers:\n        return (((double)leftHalf.Peek()+rightHalf.Peek())/2.0);\n    }\n}",
    "problemId": "find-median-in-a-data-stream",
    "statusDescription": "Accepted",
    "time": "0.478",
    "date": "2024-10-25T00:57:04.473Z",
    "memory": 53980,
    "stdout": "",
    "stderr": ""
}