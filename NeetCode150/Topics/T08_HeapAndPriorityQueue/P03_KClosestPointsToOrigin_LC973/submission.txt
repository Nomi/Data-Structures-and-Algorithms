3, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    public int[][] KClosest(int[][] points, int k) {\n        return attempt1(points, k);\n    }\n\n    public int[][] attempt1(int[][] points, int k)\n    {\n        if(points.Length<=k)\n            return points;\n        PriorityQueue<int[], double> q = new();\n        for(int i=0; i<points.Length; i++)\n        {\n            Console.WriteLine($\"{points[i][0]}, {points[i][1]}, {DistanceFromOrigin(points[i])}\");\n            if(q.Count < k)\n            {\n                q.Enqueue(points[i], -DistanceFromOrigin(points[i])); //MaxHeap\n                continue;\n            }\n            var maxDistThusFar = DistanceFromOrigin(q.Peek());\n            var curDist = DistanceFromOrigin(points[i]);\n            if(maxDistThusFar>curDist)\n            {\n                q.Dequeue();\n                q.Enqueue(points[i], curDist);\n            }\n        }\n\n        int[][] res = new int[k][];\n        for(int i=0;i<k;i++)\n        {\n            res[i] = q.Dequeue();\n        }\n        return res;\n    }\n\n    public static double DistanceFromOrigin(int[] point)\n    {\n        return Math.Sqrt(Math.Pow(point[0],2)+Math.Pow(point[1], 2));\n    }\n}\n",
    "problemId": "k-closest-points-to-origin",
    "statusDescription": "Accepted",
    "time": "0.499",
    "date": "2024-10-22T21:32:08.062Z",
    "memory": 53588,
    "stdout": "",
    "stderr": ""
}