1, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    public int CountSubstrings(string s) {\n        return attempt1(s);\n    }\n\n    int attempt1(string s)\n    {\n        int count = 0;\n        for(int i = 0; i<s.Length; i++)\n        {\n            //ODD LENGTH PALINDROMES:\n            int l = i;\n            int r = i;\n            for(; l>=0 && r<s.Length; l--, r++)\n            {\n                if(s[l]!=s[r]) //This is DP part because we cull the search space here. Because `a{palindrome}b` is not a palindrome. //Also handles the basecase of single letter for odd pallindromic subtrings loop.\n                    break;\n                //Since `a{palindrome}a` and `a` are palindromic this loop will break only when the first non palindromic string is found.\n                count++;\n            }\n            \n            //EVEN LENGTH PALINDROMES:\n            l = i;\n            r = i+1;\n            for(; l>=0 && r<s.Length; l--, r++)\n            {\n                if(s[l]!=s[r]) //This is DP part because we cull the search space here. Because `a{palindrome}b` is not a palindrome.\n                    break;\n                //Since `a{palindrome}a` and `a` are palindromic this loop will break only when the first non palindromic string is found.\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    // int attempt1(string s)\n    // {\n    //     //FCK I MISREAD THE PROBLEM (but this time it was due to reading it yesterday and doing it now.)\n    //     // if(s.Length<1)\n    //     //     return s.Length;\n\n    //     // (int l, int r) max = (0,0);\n    //     int maxLen = 0; //DEPRECATED: //=1;//could do 0 and it'd still work since we return above for empty str anyway.\n\n    //     for(int i = 0; i<s.Length; i++)\n    //     {\n    //         //ODD LENGTH PALINDROMES:\n    //         int l = i;\n    //         int r = i;\n    //         for(; l>=0 && r<s.Length; l--, r++)\n    //         {\n    //             Console.WriteLine($\"ODD Candidate ?? {l},{r}\");\n    //             if(s[l]!=s[r]) //This is DP part because we cull the search space here. Because `a{palindrome}b` is not a palindrome. //Also handles the basecase of single letter for odd pallindromic subtrings loop.\n    //                 break;\n    //             Console.WriteLine($\"ODD Palindrome == {l},{r}\");\n    //             //Since `a{palindrome}a` and `a` are palindromic this loop will break only when the first non palindromic string is found.\n    //         }\n    //         r--; l++; //Because the current position of these are not palindromes (since we broke out of the loop), but the one right before it should be (because of above loop)\n    //         if(maxLen < r-l+1)\n    //         {\n    //             // max = (r, l);\n    //             maxLen = r-l+1;\n    //         }\n\n    //         //EVEN LENGTH PALINDROMES:\n    //         l = i;\n    //         r = i+1;\n    //         for(; l>=0 && r<s.Length; l--, r++)\n    //         {\n    //             if(s[l]!=s[r]) //This is DP part because we cull the search space here. Because `a{palindrome}b` is not a palindrome.\n    //                 break;\n    //             //Since `a{palindrome}a` and `a` are palindromic this loop will break only when the first non palindromic string is found.\n    //         }\n    //         r--; l++; //Because the current position of these are not palindromes (since we broke out of the loop), but the one right before it should be (because of above loop)\n    //         if(maxLen < r-l+1)\n    //         {\n    //             // max = (r, l);\n    //             maxLen = r-l+1;\n    //         }\n    //     }\n\n    //     return maxLen;\n    // }\n}\n",
    "problemId": "palindromic-substrings",
    "statusDescription": "Accepted",
    "time": "0.426",
    "date": "2024-12-02T15:45:31.476Z",
    "memory": 55916,
    "stdout": "",
    "stderr": ""
}