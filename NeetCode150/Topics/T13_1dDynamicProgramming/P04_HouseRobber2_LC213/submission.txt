1, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    public int Rob(int[] nums) {\n        //MY FIRST IDEA: WE JUST ROB UNTIL WE GET TO THE END AND THEN FOR THE LAST HOUSE WE DECIDE WHETHER TO ROB IT OR NOT BASED ON IF THE FIRST HOUSE WAS ROBBED.\n        //WE ONLY NEED TO ENSURE ONE THING (im not fully sure, so watch neetcode or greghogg or striver video afterwards):\n        //  IF WE ROB FIRST HOUSE, DON'T ROB LAST HOUSE.\n        return dfsWrapper1(nums);\n\n        //Actually, Bottom-Up and Space Optimized Bottom-Up solutions were easier for me to concieve here because you could have separate arrays for each (robbing first house and not robbing).\n        //I checked the neetcodeio solutions and it's basically the same thing. Though, they did do them in a smarter way I guess. (creating a helper and calculate for each robbing first house and not robbing and then return the max among them) \n        //As such, in interest of time, I'll just take another good look at them and move to the next problem!  [ my interview is in 2 days :'( ]\n\n        //DO MAKE SURE TO DO THEM WHEN DONE WITH THE INTERVIEW!!\n    }\n    int dfsWrapper1(int[] nums)\n    {\n        var maxProfit = new int[nums.Length][]; //2 for bool;\n        for (int i = 0; i < nums.Length; i++) \n        {\n            maxProfit[i] = new int[] {-1, -1};//neetcodeio doesn't support yet: [-1, -1];\n        }\n        return dfs(0, nums, maxProfit);\n    }\n    //Had to take a look at the neetcodeio soln to see exactly how to do this (after trying a little, but hadn't added the flag as second argument of memo (TBF, I was thinking whether I should are not))\n    int dfs(int house, int[] nums, int[][] maxProfit, int wasFirstHouseRobbed = 0) // MEMOIZED TC: O(HOUSES) (each house computed only once) MEMOIZED SC: O(HOUSES) (because max stored for each house) //BRUTEFORCE (no memo) TC: O(2^HOUSES)\n    {\n        if(house >= nums.Length || (house == nums.Length-1 && wasFirstHouseRobbed == 1))\n            return 0;\n        if(maxProfit[house][wasFirstHouseRobbed] == -1)\n        {\n            int dontRobCur = dfs(house+1, nums, maxProfit, wasFirstHouseRobbed);\n\n            int robCur = nums[house] + dfs(house+2, nums, maxProfit, (house == 0 || wasFirstHouseRobbed ==  1? 1 : 0));//can't rob next house\n            \n            maxProfit[house][wasFirstHouseRobbed] = robCur > dontRobCur ? robCur : dontRobCur; //remember, before first house is robbed, it isn't robbed so flag should be 0/false then too.\n        }\n\n        return maxProfit[house][wasFirstHouseRobbed];\n    }\n\n}\n",
    "problemId": "house-robber-ii",
    "statusDescription": "Accepted",
    "time": "0.415",
    "date": "2024-12-01T22:36:49.277Z",
    "memory": 56620,
    "stdout": "",
    "stderr": ""
}