2, Wrong Answer
{
    "language": "csharp",
    "code": "public class Solution {\n    public string LongestPalindrome(string s) {\n        //Read more in my DP notes (were created in `Climbing Stairs` but might move them later to a Markdown file.)\n        //WATCH NEETCODE VIDEO!! (I haven't yet, but I might.)\n        //Check my soln.\n        //Check neetcodeio soln to see how to do it with minor changes (e.g. array instead of dict).\n\n        return dpLongestPalindrome(s);\n    }\n\n    string dpLongestPalindrome(string s)\n    {\n        (int l, int r) max = (0,0); //Thought of setting to 0, 0 from neetcodeio soln.\n        //Read more in my DP notes (the section for Palindromes) (notes were created in `Climbing Stairs` but might move them later to a Markdown file.)\n        if(s.Length<1)\n            return s[max.l .. max.r]; //already handled by loop? (this is more efficient tho)\n        // string res = new(s[0]); //new for char to string\n        Dictionary<(int l, int r), bool> isPalindrome = new(); //Used dict to see if I can save space (instead of whole array), though array might have been easier to implement\n\n        for(int i = 0; i<s.Length; i++)\n        {\n            //LONGEST ODD LENGTH PALINDROMIC SUBSTRING: (because we expand equally with one char at center, the windows only calculate the odd palindromes)\n            int l = i;\n            for(int r=l; r<s.Length && l>=0; r++, l--) //r=l(=i) because we start from the case of only 1 character\n            {\n                // Console.WriteLine($\"{s[max.l .. max.r]} : {l},{r}\");\n\n                if(s[l]!=s[r]) //Can't be a palindrome ever if the last and first of the string aren't the same.\n                {\n                    isPalindrome[(l,r)] = false;\n                    continue;\n                }                \n                \n                //Now, we need to check if the string between these equal characters is a palindrome (only then will the final string be a palindrome)\n                if(r-l+1<=3 || (isPalindrome.ContainsKey((l,r)) && isPalindrome[(l,r)]))\n                {\n                    //j-i<=3 == means we only have 3, 2 or 1 characters in the substring/interval.\n                    //Therefore, it would be a palindrome in that case (because 1 char is always palindrome && 2 EQUAL chars are palindrome && 2 EQUAL CHARS SURROUNDING ANY CHAR IS A PALINDROME)\n                    //Then, using these as basecases, then use the fact that `a{palindrome}a` (a could be any letter) is a palindrome.\n                    //Since we already checked for equality above, for intervals bigger than 2, we only need to check if they have palindrome in middle.\n                    isPalindrome[(l,r)] = true;\n                    if((max.r-max.l+1)<(r-l+1))//+1 cuz its length though here since its on both sides we could cancel it out. Just keeping it there as a general reminder.\n                        max = (l,r);\n                }\n            }\n\n            //LONGEST EVEN LENGTH PALINDROMIC SUBSTRING:\n            l = i;\n            for(int r=l+1; r<s.Length && l>=0; r++, l--) //r=l(=i) because we start from the case of only 1 character\n            {\n                //!!! ONLY DIFFERENCE IS `r=l+1` instead of `r=l` \n                //(previously we had 1 char in middle all the time because we started from 1 char (so we were stuck to only calculating for odd lengths), but this time we expand from a 2char window and since we expand both sides by 1 each time, this remains even length window and as such we only cover all the even length windows with it)\n                if(s[l]!=s[r])\n                {\n                    isPalindrome[(l,r)] = false;\n                    continue;\n                }                \n                \n                if(r-l+1<=3 || (isPalindrome.ContainsKey((l,r)) && isPalindrome[(l,r)]))\n                {\n                    \n                    isPalindrome[(l,r)] = true;\n                    if((max.r-max.l+1)<(r-l+1))//+1 cuz its length though here since its on both sides we could cancel it out. Just keeping it there as a general reminder.\n                        max = (l,r);\n                }\n            }\n        }\n        Console.WriteLine(max);\n        return s[max.l .. (max.r+1)];\n    }\n}\n",
    "problemId": "longest-palindromic-substring",
    "statusDescription": "Wrong Answer",
    "time": "0.398",
    "date": "2024-12-02T03:02:20.649Z",
    "memory": 57656,
    "stdout": "",
    "stderr": ""
}