6, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    public string LongestPalindrome(string s) {\n        //Read more in my DP notes (were created in `Climbing Stairs` but might move them later to a Markdown file.)\n        //WATCH NEETCODE VIDEO!! (I haven't yet, but I will.)\n        //  There might be better way to do this than two loops there.\n        //Check my soln. //DEPRECATED(My solution has Constant space complexity): (but neetcodeio soln does some things smarter/simpler!)\n        //Check neetcodeio soln to see how to do it with minor changes (e.g. array instead of dict).\n\n        return dpLongestPalindrome(s);\n    }\n\n    string dpLongestPalindrome(string s) //TC: O(n^2) //SC: O(n^2) //[there are n^2 possible substrings in a string where n is length of string e.g. \"ab\" => \"\", \"a\", \"b\", \"ab\".]\n    {\n        (int l, int r) max = (0,0); //Thought of setting to 0, 0 from neetcodeio soln.\n        //Read more in my DP notes (the section for Palindromes) (notes were created in `Climbing Stairs` but might move them later to a Markdown file.)\n        if(s.Length<=1)\n            return s[0 .. s.Length]; //already handled by loop? (this is more efficient tho)\n        // string res = new(s[0]); //new for char to string\n        Dictionary<(int l, int r), bool> isPalindrome = new(); //Used dict to see if I can save space (instead of whole array), though array might have been easier to implement\n        \n        ///AAAHHH I HAD l>0 instead of l>=0 earlier:\n        for(int i = 0; i<s.Length; i++)\n        {\n            //LONGEST ODD LENGTH PALINDROMIC SUBSTRING: (because we expand equally with one char at center, the windows only calculate the odd palindromes)\n            int l = i;\n            for(int r=l; r<s.Length && l>=0; r++, l--) //r=l(=i) because we start from the case of only 1 character\n            {\n                // Console.WriteLine($\"ODD: {s[l .. (r+1)]} : {l},{r}\");\n\n                if(s[l]!=s[r]) //Can't be a palindrome ever if the last and first of the string aren't the same.\n                {\n                    isPalindrome[(l,r)] = false;\n                    continue;\n                }                \n                \n                //Now, we need to check if the string between these equal characters is a palindrome (only then will the final string be a palindrome)\n                //AHHH I WAS DOING l,r FOR MEMO STUFF WHICH IS DUMB!\n                if(r-l+1<=3 || (isPalindrome.ContainsKey((l+1,r-1)) && isPalindrome[(l+1,r-1)]))\n                {\n                    //j-i<=3 == means we only have 3, 2 or 1 characters in the substring/interval.\n                    //Therefore, it would be a palindrome in that case (because 1 char is always palindrome && 2 EQUAL chars are palindrome && 2 EQUAL CHARS SURROUNDING ANY CHAR IS A PALINDROME)\n                    //Then, using these as basecases, then use the fact that `a{palindrome}a` (a could be any letter) is a palindrome.\n                    //Since we already checked for equality above, for intervals bigger than 2, we only need to check if they have palindrome in middle.\n                    isPalindrome[(l,r)] = true;\n                    if((max.r-max.l+1)<(r-l+1))//+1 cuz its length though here since its on both sides we could cancel it out. Just keeping it there as a general reminder.\n                        max = (l,r);\n                }\n            }\n\n            //LONGEST EVEN LENGTH PALINDROMIC SUBSTRING:\n            l = i;\n            for(int r=l+1; r<s.Length && l>=0; r++, l--) //r=l(=i) because we start from the case of only 1 character\n            {\n                //!!! ONLY DIFFERENCE IS `r=l+1` instead of `r=l` \n                //(previously we had 1 char in middle all the time because we started from 1 char (so we were stuck to only calculating for odd lengths), but this time we expand from a 2char window and since we expand both sides by 1 each time, this remains even length window and as such we only cover all the even length windows with it)\n                \n                Console.WriteLine($\"EVEN: {s[l .. (r+1)]} : {l},{r}\");\n                if(s[l]!=s[r])\n                {\n                    isPalindrome[(l,r)] = false;\n                    continue;\n                }                \n                \n                //AHHH I WAS DOING l,r FOR MEMO STUFF WHICH IS DUMB!\n                if(r-l+1<=3 || (isPalindrome.ContainsKey((l+1,r-1)) && isPalindrome[(l+1,r-1)]))\n                {\n                    \n                    isPalindrome[(l,r)] = true;\n                    if((max.r-max.l+1)<(r-l+1))//+1 cuz its length though here since its on both sides we could cancel it out. Just keeping it there as a general reminder.\n                        max = (l,r);\n                }\n                // if(l==0&&r==3) Console.WriteLine($\"{r-l+1<=3} || ({isPalindrome.ContainsKey((l,r))} && {isPalindrome[(l,r)]})\");\n            }\n        }\n        Console.WriteLine(max);\n        return s[max.l .. (max.r+1)];\n    }\n}\n",
    "problemId": "longest-palindromic-substring",
    "statusDescription": "Accepted",
    "time": "0.427",
    "date": "2024-12-02T04:23:17.342Z",
    "memory": 57168,
    "stdout": "",
    "stderr": ""
}