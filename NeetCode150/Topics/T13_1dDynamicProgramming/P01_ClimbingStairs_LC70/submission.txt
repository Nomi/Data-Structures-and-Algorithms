7, Accepted
{
    "language": "csharp",
    "code": "//[IMPORTANT!] NOT REALLY HARD! MARKED/STARRED FOR BRINGING ATTENTION TO THESE NOTES ABOUT DP:\n\n//## DP PATTERNS: {Get Grokking DP patterns course??}\n//\n// For the interview just do memoization first then explain how you might create tabulation?\n//\n// DP GENERALLY ONLY USED TO GET NUMERIC RESULTS? (like number of ways to do something than the ways themselves (which would generally require recursive backtracking))\n//\n// Got these (except Fibonacci) from Neetcode's Advanced Algorithms course videos about them.\n//\n// My observation: Non-optimized tabulation ends up with a similar array to the memo we would have otherwise built for memoization (even what's inside / how to build it). \n//      (I think this can make solving tabulation based DP easier because now you know exactly what kind of array you want to build, and you have a general idea of how to build it.)\n//\n// My observation: Generally, in tabulation DP (bottom up) the order of the table (like where we start or end) doesn't matter (so you can disregard any confused comments I made about this initially),\n//                      we only chose a specific order for the table if we find a case where doing so could be useful or inuitive (e.g. mirroring original martix, etc.)\n//\n//:::::::::::::::::::::::::::::\n//### Fibonacci [to calculate a value]: {wrote this one on my own, so there might be some incorrect stuff}\n//  - Memoization (Top-down):\n//      Really just stores the result for each input (as 1D array).\n//  - Tabulation (Bottom-Up):\n//      Uses a similar array to Memoization and iteratively \n//      fills the array starting from before (the first k e.g. k==2 in actual fibonacci) are manually set (to values of base cases in memoization's recursion)\n//  - Optimized Tabulation (Bottom-Up): \n//      Constant space you realize you only really need as many as last k values (the number of base cases) (e.g. k==2 in actual fibonacci), so you use an array to store them.\n//:::::::::::::::::::::::::::::\n//### 0/1 Knapsack (take / not take) [Optimitze cost-to-value] [More explanation: to maximize (or minimize?) cost/weight_or_count/population/profit within budget/storage/space/capacity limits]: {WROTE THIS MOSTLY, if not fully, ON MY OWN!!!}\n//  - Memoization (top-down):\n//      Uses recursive backtracking where for each item we consider adding it or not adding it (then moving onto the next one).\n//          Our conditions to stop are 1. going over the weight limit or 2. running out of items.\n//      We only calculate (and return) the final number of ways for each item with given capacity in POST ORDER.\n//      Uses a 2D memo array that stores the result of the function call for each input pairing of indexOfElementConsidered and spaceLeft\n//      Since it is memoization, it is still based on a recursive backtracking take-or-not approach.\n//  - Tabulation (Bottom-Up): \n//      (Notice how the last level of post-order recursive calls in the backtracking solution will basically (since it has no context of total profit in the above recursive level) calculate max profit we can get if we only consider adding the current level 1 or 0 times given the current capacity)\n//      (Our tabulation based approach uses the above idea, but since the order of items (rows) doesn't really matter, order of the table based on items doesn't matter either and there is no specific benefit of choosing any order, so we choose to start from any item(row), so we start from the first row to keep things simpler)\n//      Note that order of picking doesn't matter, but we will manually enforce one to make it work/efficient.\n//      As usual, you use a similar array to the memoization soln where memo[itemIdx][capacity] stores the maximum profit possible only considering items from 0 to itemIdx (whether we take it or not) when `capacity` is the capacity left.\n//      We start by manually filling the whole first row(its base case) (maximum profit possible when only considering item at idx 0 for capacities 0 through maximum capacity (starting/original capacity of bag (empty bag)))\n//      For each column in the rest of the rows, let row = r and c = col, we SET \n//          `memo[r][c]` TO THE MAXIMUM_OF `memo[r-1][c](skipping item at r: i.e. max profit using only items from [0,r-1] with capacity c)`\n//          and `profit[r] (profit by picking only current element) + memo[r-1][c-weight[r]] (max profit possible by only considering items 0 to r-1 when capacity is the capacity left after picking current item)`\n//      Clearly, at memo[N][C] where N is last item index and C is starting capacity (of empty bag),\n//          we set `maximum profit when all items are being considered and the bag is empty (starting capacity)`\n//          which is our answer. So, we can return it.\n//  - Optimized Tabulation (Bottom-Up):\n//      If you look at the above algorithm, you'll realize, for any given row, \n//      we only read values from the row prior to it,\n//      and we only set values to the current row. \n//      Therefore, we can only use a two row array to get optimize SC from O(N*C) to O(2*C)==O(N)\n//  - QUESTION: Does choosing the order of the indices of memo matter?\n//\n//:::::::::::::::::::::::::::::\n//### [2D] For Number of Unique Paths type problems [num unique paths from (0,0) to (ROWS-1,COLS-1) of matrix]: {WROTE THIS ON MY OWN!}\n//  - It is kinda similar to 0/1 Knapsack (BOUNDED) because you can only choose 1 out of 2 nodes (down or right) for each unique path.\n//  - The recursive call would start POSTORDER from (0,0) and recursively figure out how to get there from nodes above and below it. (and same for each of them) [Base cases: 1. out of bounds => 0, 2. Reached Destination=> 1]\n//  - This is like Knapsack, but we reverse the order of items to basically mirror how our graph/matrix would be originally to keep things simpler/easier (to do and a lot more to be readable/understandable)\n//  - However, the differences are that:\n//      * We start from computing the only the last row first (base case) (each node from there has only one way to go, which is right, so everything == 1) \n//              [Because (not sure!?)\n//                  1. We sort of inverted the problem to: How many ways from each node can we get to the ending, because that makes it easier/possible to calculate what we want \n//                  2. While order matters unlike in knapsack (because we need the last index of the last row first and the ones directly connected to it first), \n//                          we can flip the matrix and still keep the same order as long as we also 'flip' our logic.\n//                  3. This mirrors the original matrix that was provided (or should exist if only given dimensions) and this makes things simpler  (e.g. directions are consistently up and down). \n//                          So, even if we could flip this whole matrix (which would require changing the logic a LITTLE), we won't do it because this way we get to keep things consistent with orignal matrix.\n//      * Then for each node, number of ways to get from there to original node is the number of ways to get to the destination is the \n//          sum of number of ways to get to destination from the node to the right and node to the left (this is where DP saves us).\n//      * Recursion based solution also uses similar approach just using recursion to do it and memoization just memoizes these results.\n//\n//:::::::::::::::::::::::::::::\n//### Unbounded Knapsack [Optimized cost-to-value, but can pick same item unlimited times (unlimited quantities of items)] {wrote all of this on my own LET'S GOOO!!! Will watch neetcode video anyway, but won't edit notes unless something new comes up,}\n//  {Like 0/1 Knapsack. Seems to be more common in interviews (according to NeetCode).}\n//  - Memoization (top-down):\n//      Uses Post-Order Recursive Backtracking to decide whether to add current item or not, BUT\n//          there are more than n+2 branches in each recursion where n is the number of times this item can be kept with the current capacity: \n//              1. {RECURSIVELY} Do not pick item and move to next index. \n//              3. `FOR i=1; i*curItm.Weight <= capacityAtCurrentBranch; i++`:\n//                      Inside Loop: {RECURSIVELY} Pick item for i-th time and move to next index. \n//                  LIKE WE STUDIED IN BACKTRACKING SECTION: \n//                      HERE, CLEARLY THE ORDER WE PICK ITEMS IN DOESN'T MATTER (so it's fine to pick all of this item we will be taking at once)\n//                      THIS LOOP WILL COVER ALL POSSIBLE NUMBER OF TIMES WE CAN PICK THIS ITEM.\n//              4. Note that we only really need to store the max profit at given capacity, so number of repetitions don't need to be tracked, just all repetions should be considered and then the max one of those is stored in the memo for a node/function_call.\n//      Here, an interesting observation would be, if we have already computed MAX PROFIT FOR EACH (curItemIdx, capacity), we can just cache that and return everytime this question is asked.\n//          This is where the memo/cache comes in.\n//  - Tabulation (Bottom-Up):\n//      As always, non-optimized tabulation ends up with a similar array to memoization, therefore, let's think of how we can build it iteratively.\n//      (Notice how the last level of post-order recursive calls in the backtracking solution will basically (since it has no context of total profit in the above recursive level) calculate max profit we can get if we only consider adding the current level any number of times given the current capacity)\n//      (Our tabulation based approach uses the above idea, but since the order of items doesn't really matter, we can start from any item, so we start from the first row)\n//      Due to the above 2 lines, we start from the generating the first sub array of what would have been the memo:\n//          First, foreach capacity in [0, COLS): table[0][capacity] = max profit if we can only include first item unlimited times for given capacity. (should be easy)\n//          Then, foreach i-th row(1 row for each item), starting from i = 1:\n//                      table[i][1] = table[i]\n//                      foreach capacity in [1, COLS): //we start form 1 because 0 capacity => 0 profit.\n//                          noTakeProfit = table[i-1][capacity]; //MAX CAPACITY IF WE DON'T INCLUDE CURRENT ITEM\n//                          takeProfit = int.MinValue;\n//                          if(capacity-weight[i] >= 0)\n//                          {\n//                              takeProfit = profit[i] + table[i][capacity-weight[i]];\n//                              //The above line is Different from Bounded Knapsack (to handle repeatability of same item)\n//                              //It is == profit of including current item once + table[i][capacity-weight[i]]\n//                              //Where table[i][capacity-weight[i]] == Max Profit if we could include any items from [0, i] with the remaining capacity after including 1st item once.\n//                              //    (notice i can be used again here, unlike in Bounded Knapsack).\n//                          }\n//                          table[i][capacity] = Math.Max(takeProfit, noTakeProfit); // MAX_PROFIT_AT_CURRENT_CAPACITY_IF_WE_ONLY_CONSIDER_CURRENT_ITEMS_OR_ONES_BEFORE_IT\n//                      NOTICE THAT THIS WORKS BECAUSE IN ANY row table[i], table[i][1] gets filled by `noTake`, and the rest use it directly or indirectly for their take (repeating same item), while comparing with the row above for noTake.\n//                      Then at table[i][2], if weight limit allows, we set it to MAXIMUM_OF profit[i] + max of repeating at i most 1 times just OR not taking it at all.\n//                      Here, we don't really care HOW (repetition or not (take/noTake chain)), we just want the maximum profit if we have this much capacity.\n//\n//          Then the result is in the final column of the final row of the table, because it STORES MAXIMUM PROFIT IF WE CAN CONSIDER ALL COMBINATION OF\n//              ITEMS ([0,numAllItems]), FOR THE FULL CAPACITY (capacity of EMPTY KNAPSACK).\n//  - Optimized Tabulation (Bottom-Up):\n//      Notice we only need first two rows. The rest is like Bounded KnapSack.\n//:::::::::::::::::::::::::::::\n//### Longest Common Sequence:\n//\n//  - Memoization (top-down):\n//\n//  - Tabulation (Bottom-Up):\n//\n//  - Optimized Tabulation (Bottom-Up):\n//\n//:::::::::::::::::::::::::::::\n//### Palindromes:\n//  - Memoization (top-down):\n//\n//  - Tabulation (Bottom-Up):\n//\n//  - Optimized Tabulation (Bottom-Up):\n//\n//:::::::::::::::::::::::::::::\n//### DP on strings, bitmask, and digits???\n//:::::::::::::::::::::::::::::\n\npublic class Solution {\n    public int ClimbStairs(int n) {     \n        if(n<3)\n            return n;\n        //Seems to be the Fibonacci pattern for DP.\n        //at i==0 we are at the ground.\n        int prevPrev = 1; //i==1 from i==0\n        int prev = 2; //i==2 from i == 0 (two once or one twice)\n        for(int i = 3; i < n+1; i++)\n        {\n            //curNumWays = (numWaysToGetAtPrev*numWaysFromPrev + numWaysToGetAtPrevPrev*numWaysFromPrevPrev). Here, as explained in the actual assignment, numWaysFromPrev == 1 & numWaysFromPrevPrev == 1.\n            int curWays = \n                (prev) //Only one possible choice to get here from prev, so we don't need prev+1 or prev+2 as I tried doing earlier.\n                + (prevPrev); //Only one possible choice to get here from prevPrev: two steps at once  (one step twice NOT INCLUDED because it is included in prev)\n            prevPrev = prev;\n            prev = curWays;\n\n            //Note: at i-th iteration, prevPrev = {curWays at i-2th iteration} and prev = {curWays at idx i-1th iteration}\n            //So, at i == (n-1), prev becomes == `curWaysAtN-1 = curWaysAtN-3 + curWaysAtN-2`\n        }\n\n        return prev; //for i==n\n    }\n}\n",
    "problemId": "climbing-stairs",
    "statusDescription": "Accepted",
    "time": "0.399",
    "date": "2024-12-01T17:19:50.756Z",
    "memory": 54604,
    "stdout": "",
    "stderr": ""
}