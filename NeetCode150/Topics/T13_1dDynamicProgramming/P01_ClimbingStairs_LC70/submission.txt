6, Accepted
{
    "language": "csharp",
    "code": "//[IMPORTANT!] NOT REALLY HARD! MARKED/STARRED FOR BRINGING ATTENTION TO THESE NOTES ABOUT DP:\n\n//## DP PATTERNS: {Get Grokking DP patterns course??}\n//\n// For the interview just do memoization first then explain how you might create tabulation?\n//\n// DP GENERALLY ONLY USED TO GET NUMERIC RESULTS? (like number of ways to do something than the ways themselves (which would generally require recursive backtracking))\n//\n// Got these (except Fibonacci) from Neetcode's Advanced Algorithms course videos about them.\n//\n// My observation: Non-optimized tabulation ends up with a similar array to the memo we would have otherwise built for memoization (even what's inside / how to build it). \n//      (I think this can make solving tabulation based DP easier because now you know exactly what kind of array you want to build, and you have a general idea of how to build it.)\n//\n//:::::::::::::::::::::::::::::\n//### Fibonacci [to calculate a value]: {wrote this one on my own, so there might be some incorrect stuff}\n//  - Memoization (Top-down):\n//      Really just stores the result for each input (as 1D array).\n//  - Tabulation (Bottom-Up):\n//      Uses a similar array to Memoization and iteratively \n//      fills the array starting from before (the first k e.g. k==2 in actual fibonacci) are manually set (to values of base cases in memoization's recursion)\n//  - Optimized Tabulation (Bottom-Up): \n//      Constant space you realize you only really need as many as last k values (the number of base cases) (e.g. k==2 in actual fibonacci), so you use an array to store them.\n//:::::::::::::::::::::::::::::\n//### 0/1 Knapsack (take / not take) [Optimitze cost-to-value] [More explanation: to maximize (or minimize?) cost/weight_or_count/population/profit within budget/storage/space/capacity limits]: {WROTE THIS MOSTLY, if not fully, ON MY OWN!!!}\n//  - Memoization (top-down):\n//      Uses recursive backtracking where for each item we consider adding it or not adding it (then moving onto the next one).\n//          Our conditions to stop are 1. going over the weight limit or 2. running out of items.\n//      We only calculate (and return) the final number of ways for each item with given capacity in POST ORDER.\n//      Uses a 2D memo array that stores the result of the function call for each input pairing of indexOfElementConsidered and spaceLeft\n//      Since it is memoization, it is still based on a recursive backtracking take-or-not approach.\n//  - Tabulation (Bottom-Up): \n//      (??? [IMP!] Since in bruteforce or memoization we only calculate (and return) the final number of ways for each item with given capacity in POST ORDER RECURSIVE BACKTRACKING, our memo's bottom rows are filled first. ???)\n//      (???    As such we use a similar approach when creating the table here. The first row ???)\n//      Note that order of picking doesn't matter, but we will manually enforce one to make it work/efficient.\n//      As usual, you use a similar array to the memoization soln where memo[itemIdx][capacity] stores the maximum profit possible only considering items from 0 to itemIdx (whether we take it or not) when `capacity` is the capacity left.\n//      We start by manually filling the whole first row(its base case) (maximum profit possible when only considering item at idx 0 for capacities 0 through maximum capacity (starting/original capacity of bag (empty bag)))\n//      For each column in the rest of the rows, let row = r and c = col, we SET \n//          `memo[r][c]` TO THE MAXIMUM_OF `memo[r-1][c](skipping item at r: i.e. max profit using only items from [0,r-1] with capacity c)`\n//          and `profit[r] (profit by picking only current element) + memo[r-1][c-weight[r]] (max profit possible by only considering items 0 to r-1 when capacity is the capacity left after picking current item)`\n//      Clearly, at memo[N][C] where N is last item index and C is starting capacity (of empty bag),\n//          we set `maximum profit when all items are being considered and the bag is empty (starting capacity)`\n//          which is our answer. So, we can return it.\n//  - Optimized Tabulation (Bottom-Up):\n//      If you look at the above algorithm, you'll realize, for any given row, \n//      we only read values from the row prior to it,\n//      and we only set values to the current row. \n//      Therefore, we can only use a two row array to get optimize SC from O(N*C) to O(2*C)==O(N)\n//  - QUESTION: Does choosing the order of the indices of memo matter?\n//\n//:::::::::::::::::::::::::::::\n//### [2D] For Number of Unique Paths type problems [num unique paths from (0,0) to (ROWS-1,COLS-1) of matrix]: {WROTE THIS ON MY OWN!}\n//  - It is kinda similar to 0/1 Knapsack (BOUNDED) because you can only choose 1 out of 2 nodes (down or right) for each unique path.\n//  - However, the differences are that:\n//      * We start from computing the only the last row first (each node from there has only one way to go, which is right, so everything == 1) [Because 1. We sort of inverted the problem to: How many ways from each node can we get to the ending, because that makes it easier/possible to calculate what we want 2. The recursive backtracking solution was post-order ??]\n//      * Then for each node, number of ways to get from there to original node is the number of ways to get to the destination is the \n//          sum of number of ways to get to destination from the node to the right and node to the left (this is where DP saves us).\n//      * Recursion based solution also uses similar approach just using recursion to do it and memoization just memoizes these results.\n//\n//:::::::::::::::::::::::::::::\n//### Unbounded Knapsack [Optimized cost-to-value, but can pick same item unlimited times (unlimited quantities of items)] {wrote all of this on my own LET'S GOOO!!! Will watch neetcode video anyway, but won't edit notes unless something new comes up,}\n//  {Like 0/1 Knapsack. Seems to be more common in interviews (according to NeetCode).}\n//  - Memoization (top-down):\n//      Uses Post-Order Recursive Backtracking to decide whether to add current item or not, BUT\n//          there are more than n+2 branches in each recursion where n is the number of times this item can be kept with the current capacity: \n//              1. {RECURSIVELY} Do not pick item and move to next index. \n//              3. `FOR i=1; i*curItm.Weight <= capacityAtCurrentBranch; i++`:\n//                      Inside Loop: {RECURSIVELY} Pick item for i-th time and move to next index. \n//                  LIKE WE STUDIED IN BACKTRACKING SECTION: \n//                      HERE, CLEARLY THE ORDER WE PICK ITEMS IN DOESN'T MATTER (so it's fine to pick all of this item we will be taking at once)\n//                      THIS LOOP WILL COVER ALL POSSIBLE NUMBER OF TIMES WE CAN PICK THIS ITEM.\n//      Here, an interesting observation would be, if we have already computed MAX PROFIT FOR EACH (curItemIdx, capacity), we can just cache that and return everytime this question is asked.\n//          This is where the memo/cache comes in.\n//  - Tabulation (Bottom-Up):\n//      As always, non-optimized tabulation ends up with a similar array to memoization, therefore, let's think of how we can build it iteratively.\n//      (Notice how the last level of post-order recursive calls in the backtracking solution will basically (since it has no context of total profit in the above recursive level) calculate max profit we can get if we only consider adding the current level any number of times given the current capacity)\n//      (Our tabulation based approach uses the above idea, but since the order of items doesn't really matter, we can start from any item, so we start from the first row)\n//      Since memoization used a solution, we start from the first sub array and generate it as:\n//          First, foreach capacity in [0, COLS): table[0][capacity] = max profit if we can only include first item unlimited times for given capacity. (should be easy)\n//          Then, foreach i-th row(1 row for each item), starting from i = 1:\n//                      table[i][1] = table[i]\n//                      foreach capacity in [1, COLS): //we start form 1 because 0 capacity is invalid.\n//                          table[i][capacity] = MAX_PROFIT_AT_CURRENT_CAPACITY_IF_WE_ONLY_CONSIDER_CURRENT_ITEMS_OR_ONES_BEFORE_IT\n//                          Here, MAX_PROFIT_AT_CURRENT_CAPACITY_IF_WE_ONLY_CONSIDER_CURRENT_ITEMS_OR_ONES_BEFORE_IT =\n//                          MAX\n//                          (\n//                              table[i-1][capacity], //MAX CAPACITY IF WE DON'T INCLUDE CURRENT ITEM\n//                              profit[i] + table[i][capacity-weight[i]] \n//                              //The above line is Different from Bounded Knapsack \n//                              //It is == profit of including current item once + table[i][capacity-weight[i]]\n//                              //Where table[i][capacity-weight[i]] == Max Profit if we could include any items from [0, i] with the remaining capacity after including i-th item once.\n//                                  (notice i can be used again here, unlike in Bounded Knapsack)\n//                          )\n//          Then the result is in the final column of the final row of the table, because it STORES MAXIMUM PROFIT IF WE CAN CONSIDER ALL COMBINATION OF\n//              ITEMS ([0,numAllItems]), FOR THE FULL CAPACITY (capacity of empty knapsack).\n//  - Optimized Tabulation (Bottom-Up):\n//\n//:::::::::::::::::::::::::::::\n//### Longest Common Sequence:\n//\n//  - Memoization (top-down):\n//\n//  - Tabulation (Bottom-Up):\n//\n//  - Optimized Tabulation (Bottom-Up):\n//\n//:::::::::::::::::::::::::::::\n//### Palindromes:\n//  - Memoization (top-down):\n//\n//  - Tabulation (Bottom-Up):\n//\n//  - Optimized Tabulation (Bottom-Up):\n//\n//:::::::::::::::::::::::::::::\n//### DP on strings, bitmask, and digits???\n//:::::::::::::::::::::::::::::\n\npublic class Solution {\n    public int ClimbStairs(int n) {     \n        if(n<3)\n            return n;\n        //Seems to be the Fibonacci pattern for DP.\n        //at i==0 we are at the ground.\n        int prevPrev = 1; //i==1 from i==0\n        int prev = 2; //i==2 from i == 0 (two once or one twice)\n        for(int i = 3; i < n+1; i++)\n        {\n            //curNumWays = (numWaysToGetAtPrev*numWaysFromPrev + numWaysToGetAtPrevPrev*numWaysFromPrevPrev). Here, as explained in the actual assignment, numWaysFromPrev == 1 & numWaysFromPrevPrev == 1.\n            int curWays = \n                (prev) //Only one possible choice to get here from prev, so we don't need prev+1 or prev+2 as I tried doing earlier.\n                + (prevPrev); //Only one possible choice to get here from prevPrev: two steps at once  (one step twice NOT INCLUDED because it is included in prev)\n            prevPrev = prev;\n            prev = curWays;\n\n            //Note: at i-th iteration, prevPrev = {curWays at i-2th iteration} and prev = {curWays at idx i-1th iteration}\n            //So, at i == (n-1), prev becomes == `curWaysAtN-1 = curWaysAtN-3 + curWaysAtN-2`\n        }\n\n        return prev; //for i==n\n    }\n}\n",
    "problemId": "climbing-stairs",
    "statusDescription": "Accepted",
    "time": "0.403",
    "date": "2024-12-01T16:04:50.186Z",
    "memory": 56352,
    "stdout": "",
    "stderr": ""
}