3, Accepted
{
    "language": "csharp",
    "code": "//[IMPORTANT!] NOT REALLY HARD! MARKED/STARRED FOR BRINGING ATTENTION TO THESE NOTES ABOUT DP:\n\n//## DP PATTERNS: {Get Grokking DP patterns course??}\n//\n// DP GENERALLY ONLY USED TO GET NUMERIC RESULTS? (like number of ways to do something than the ways themselves (which would generally require recursive backtracking))\n//\n// Got these (except Fibonacci) from Neetcode's Advanced Algorithms course videos about them.\n//\n//:::::::::::::::::::::::::::::\n//### Fibonacci [to calculate a value]: {wrote this one on my own, so there might be some incorrect stuff}\n//  - Memoization (Top-down):\n//      Really just stores the result for each input (as 1D array).\n//  - Tabulation (Bottom-Up):\n//      Uses a similar array to Memoization and iteratively \n//      fills the array starting from before (the first k e.g. k==2 in actual fibonacci) are manually set (to values of base cases in memoization's recursion)\n//  - Optimized Tabulation (Bottom-Up): \n//      Constant space you realize you only really need as many as last k values (the number of base cases) (e.g. k==2 in actual fibonacci), so you use an array to store them.\n//:::::::::::::::::::::::::::::\n//### 0/1 Knapsack (take / not take) [Optimitze cost-to-value] [More explanation: to maximize (or minimize?) cost/weight_or_count/population/profit within budget/storage/space/capacity limits]:\n//  - Memoization (top-down):\n//      Uses a 2D memo array that stores the result of the function call for each input pairing of indexOfElementConsidered and spaceLeft.\n//      Since it is memoization, it is still based on a recursive backtracking take-or-not approach.\n//  - Tabulation (Bottom-Up): \n//      Note that order of picking doesn't matter, but we will manually enforce one to make it work/efficient.\n//      As usual, you use a similar array to the memoization soln where memo[itemIdx][capacity] stores the maximum profit possible only considering items from 0 to itemIdx (whether we take it or not) when `capacity` is the capacity left.\n//      We start by manually filling the whole first row(it's base case) (maximum profit possible when only considering item at idx 0 for capacities 0 through maximum capacity (starting/original capacity of bag (empty bag)))\n//      For each column in the rest of the rows, let row = r and c = col, we SET \n//          `memo[r][c]` TO THE MAXIMUM_OF `memo[r-1][c](skipping item at r: i.e. max profit using only items from [0,r-1] with capacity c)`\n//          and `profit[r] (profit by picking only current element) + memo[r-1][c-weight[r]] (max profit possible by only considering items 0 to r-1 when capacity is the capacity left after picking current item)`\n//      Clearly, at memo[N][C] where N is last item index and C is starting capacity (of empty bag),\n//          we set `maximum profit when all items are being considered and the bag is empty (starting capacity)`\n//          which is our answer. So, we can return it.\n//  - Optimized Tabulation (Bottom-Up):\n//      If you look at the above algorithm, you'll realize, for any given row, \n//      we only read values from the row prior to it,\n//      and we only set values to the current row. \n//      Therefore, we can only use a two row array to get optimize SC from O(N*C) to O(2*C)==O(N)\n//  - QUESTION: Does choosing the order of the indices of memo matter?\n//:::::::::::::::::::::::::::::\n//### Unbounded Knapsack [Optimized cost-to-value, but can pick same item unlimited times]\n//  - Memoization (top-down):\n//\n//  - Tabulation (Bottom-Up):\n//\n//  - Optimized Tabulation (Bottom-Up):\n//\n//:::::::::::::::::::::::::::::\n//### Longest Common Sequence:\n//\n//  - Memoization (top-down):\n//\n//  - Tabulation (Bottom-Up):\n//\n//  - Optimized Tabulation (Bottom-Up):\n//\n//:::::::::::::::::::::::::::::\n//### Palindromes:\n//  - Memoization (top-down):\n//\n//  - Tabulation (Bottom-Up):\n//\n//  - Optimized Tabulation (Bottom-Up):\n//\n//:::::::::::::::::::::::::::::\n\npublic class Solution {\n    public int ClimbStairs(int n) {     \n        if(n<3)\n            return n;\n        //Seems to be the Fibonacci pattern for DP.\n        //at i==0 we are at the ground.\n        int prevPrev = 1; //i==1 from i==0\n        int prev = 2; //i==2 from i == 0 (two once or one twice)\n        for(int i = 3; i < n+1; i++)\n        {\n            //curNumWays = (numWaysToGetAtPrev*numWaysFromPrev + numWaysToGetAtPrevPrev*numWaysFromPrevPrev). Here, as explained in the actual assignment, numWaysFromPrev == 1 & numWaysFromPrevPrev == 1.\n            int curWays = \n                (prev) //Only one possible choice to get here from prev, so we don't need prev+1 or prev+2 as I tried doing earlier.\n                + (prevPrev); //Only one possible choice to get here from prevPrev: two steps at once  (one step twice NOT INCLUDED because it is included in prev)\n            prevPrev = prev;\n            prev = curWays;\n\n            //Note: at i-th iteration, prevPrev = {curWays at i-2th iteration} and prev = {curWays at idx i-1th iteration}\n            //So, at i == (n-1), prev becomes == `curWaysAtN-1 = curWaysAtN-3 + curWaysAtN-2`\n        }\n\n        return prev; //for i==n\n    }\n}\n",
    "problemId": "climbing-stairs",
    "statusDescription": "Accepted",
    "time": "0.405",
    "date": "2024-12-01T03:11:49.089Z",
    "memory": 55744,
    "stdout": "",
    "stderr": ""
}