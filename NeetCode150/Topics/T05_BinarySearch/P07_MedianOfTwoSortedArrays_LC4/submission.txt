1, Wrong Answer
{
    "date": "2024-09-22T20:19:22.484Z",
    "statusDescription": "Wrong Answer",
    "code": "public class Solution {\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\n        //My intuition (bruteforce):\n        //the bruteforce solution would be O(m+n) with two pointers, one each on nums1 and nums2 which we can use to traverse these as if they were a single sorted array (by checking which pointer is currently at a smaller value and the using that for that iteration)\n        //^^This bruteforce might be enough in an interview when followed up with just an explanation of how you would do it in O(log(m+n)) time instead.\n        //^^^ ESPECIALLY GIVEN THE EDGECASE CODE (and the code as a whole)\n        \n        // IMPORTANT NOTES: (try reading the ones with ^ suffix above first!)\n        // Just skim through the NeetCode video for a great explanation for the solution!\n        return attempt1(nums1, nums2);\n    }\n\n    public double attempt1(int[] nums1, int[] nums2) \n    {\n        var A = nums1;\n        var B = nums2;\n\n        int totalCount = A.Length + B.Length;\n        int sizeOfHalves = totalCount/2; //Integer division => decimal is truncated.\n        \n        //Time complexity: O(log(min(n,m))) //min because we are running binary search on the smaller of the two?\n        //We can binary search through B as we can calculate the remaining elements needed for each side after picking both the left and right subarrays for B.\n        int l=0, r=A.Length-1;\n        while(true) //There's guaranteed to be a median so we can just return from there when we find it!\n        {\n            int mA = (l+r)/2; //int division => truncate\n\n            //IMPORTANT: sizeOfHalves - (mA+1) \n            //is the remaining length (of the left subarray\n            // of B), then we -1 to get it as the index.\n            int idxB = (sizeOfHalves - (mA+1))-1; \n            \n\n            //[VERY IMPORTANT]: HANDLING EDGE CASES\n            var Aleft = mA>=0 ? A[mA] : int.MinValue;\n            var Aright = mA+1<A.Length ? A[mA+1] : int.MaxValue;\n            var Bleft = idxB>=0 ? B[idxB] : int.MinValue;\n            var Bright = idxB+1<B.Length ? B[idxB+1] : int.MaxValue;\n\n            //Partition is correct:\n            if(Aleft<=Bright && Bleft <= Aright)\n            {\n                if(totalCount%2==1) //odd:\n                    return Math.Min(Aright, Bright); //There will never be a case where both will be MaxValue obviously.\n                //even:\n                return (Math.Max(Aleft,Bleft) + Math.Min(Aright, Bright))/2.0; //Gotta divide by 2.0 (instead of simply 2) to get decimal division\n            }\n            else if(Aleft>Bleft) //Aleft is too big, meaning we have many elements from B on the left side <=> not enough elements in A on the left side!\n                r = mA - 1;\n            else //Bleft <= Aright\n                l = mA + 1;\n\n        }\n    }\n\n}\n",
    "memory": 54344,
    "stdout": "",
    "language": "csharp",
    "time": "0.889",
    "problemId": "median-of-two-sorted-arrays",
    "stderr": ""
}