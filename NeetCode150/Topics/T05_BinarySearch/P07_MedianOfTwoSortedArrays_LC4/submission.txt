5, Accepted
{
    "date": "2024-09-23T18:47:46.434Z",
    "statusDescription": "Accepted",
    "code": "public class Solution {\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\n        //EXTREMELY IMPORANT: Read comments from attempt1,\n        //at least for the edgecases.\n        //Watching NC's video only comes AFTER that :3.\n        //Though the LC solutions might be better!\n        \n        //My intuition (bruteforce):\n        //the bruteforce solution would be O(m+n) with two pointers, one each on nums1 and nums2 which we can use to traverse these as if they were a single sorted array (by checking which pointer is currently at a smaller value and the using that for that iteration)\n        //^^This bruteforce might be enough in an interview when followed up with just an explanation of how you would do it in O(log(m+n)) time instead.\n        //^^^ ESPECIALLY GIVEN THE EDGECASE CODE (and the code as a whole)\n        \n        // IMPORTANT NOTES: (try reading the ones with ^ suffix above first!)\n        // Just skim through the NeetCode video for a great explanation for the solution!\n        //CHECK THESE FOR STUDYING:\n        // Editorial part we need: https://leetcode.com/problems/median-of-two-sorted-arrays/editorial/#approach-3-a-better-binary-search\n        // C# solution by someone: https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/5783216/median-of-two-sorted-arrays-binary-search-approach-in-c-beginner-friendly/\n        return attempt1(nums1, nums2);\n\n        \n    }\n\n    public double attempt1(int[] nums1, int[] nums2) \n    {\n        var A = nums1;\n        var B = nums2;\n        \n        if (B.Length < A.Length) {\n            int[] temp = A;\n            A = B;\n            B = temp;\n        }\n\n        int totalCount = A.Length + B.Length;\n        int sizeOfHalves = totalCount/2; //Integer division => decimal is truncated.\n        \n        //Time complexity: O(log(min(n,m))) //min because we are running binary search on the smaller of the two.\n        //We can binary search through B as we can calculate the remaining elements needed for each side after picking both the left and right subarrays for B.\n        int l=0, r=A.Length-1;\n        while(true) //We can use While True because There's guaranteed to be a median so we can just return from there when we find it!\n        {\n\n            //** EXTREMELY IMPORTANT!  [!! EDGE CASES !!] **\n            //We want Floor for when the A (the smaller array) is \n            //of length 1 or 0, because that makes mA = -1 when\n            //((l+r)/2 == -1/2) (which happens in those cases).\n            //NeetCode's YouTube/Python solution uses \"//\",\n            //which, ONLY for positive numbers, is equivalent to int division for postiive numbers\n            //For both negative and positive, it is actually equivalent\n            //to Math.Floor().\n            int mA = (int)Math.Floor((l+r)/2.0); //int division => truncate\n\n            //IMPORTANT: sizeOfHalves - (mA+1) \n            //is the remaining length (of the left subarray\n            // of B), then we -1 to get it as the index.\n            int idxB = (sizeOfHalves - (mA+1))-1; \n            \n\n            //[VERY IMPORTANT]: HANDLING EDGE CASES\n            var Aleft = mA>=0 ? A[mA] : double.MinValue; //right most element of left window of A\n            var Aright = mA+1<A.Length ? A[mA+1] : double.MaxValue; //left most element of right window of A\n            var Bleft = idxB>=0 ? B[idxB] : double.MinValue; //right most element of left window of B\n            var Bright = idxB+1<B.Length ? B[idxB+1] : double.MaxValue; //left most element of right window of B\n\n            //Partition is correct:\n            if(Aleft<=Bright && Bleft <= Aright)\n            {\n                if(totalCount%2!=0) //odd:  //the one on right will be the one actual median because neither window should contain it for odd length, and it is ensured here by calculating half in int/truncating division.\n                    return Math.Min(Aright, Bright); //There will never be a case where both will be MaxValue obviously.\n                //even:\n                return (Math.Max(Aleft,Bleft) + Math.Min(Aright, Bright))/2.0; //Gotta divide by 2.0 (instead of simply 2) to get decimal division\n            }\n            else if(Aleft>Bright) //the right most element of left window of A is smaller than the leftmost element of right window of B (keep in mind A and B are sorted)! //Aleft is too big, meaning we have too many elements from B on the left side <=> not enough elements in A on the left side!\n                r = mA - 1;\n            else //Bleft > Aright <=> Aright < Bleft //Aleft is too small, meaning we have at least 1 element smaller than the the last element of B in our A right window! (keep in mind A and B are sorted)\n                l = mA + 1;\n        }\n        return -1;\n    }\n\n}\n",
    "memory": 52976,
    "stdout": "",
    "language": "csharp",
    "time": "0.905",
    "problemId": "median-of-two-sorted-arrays",
    "stderr": ""
}