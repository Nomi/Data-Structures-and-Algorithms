2, Wrong Answer
{
    "date": "2024-09-22T17:41:42.890Z",
    "statusDescription": "Wrong Answer",
    "code": "public class Solution {\n    public int FindMin(int[] nums) {\n        //SINCE WE HAVE SORTED INPUT (almost)\n        //AND WE ARE LOOKING FOR AN O(log(n)) solution,\n        //IT MUST BE LOOKING FOR BINARY SEARCH!\n\n        //Greg Hogg's solution (better than NeetCode's)\n        // return attempt1(nums);  //READ THE COMMENTS!\n\n        //Check NeetCode's solution as well as that might be useful for other problems as well (e.g. Search in Rotated Sorted Array)\n        return neetCodeBasedSoln(nums);\n    }\n    public int attempt1(int[] nums)\n    {\n        //My observations:\n        //Clearly, we can identify max when the next element is smaller than current.\n        //Clearly, the min element will be right after the max one.\n        //(Could also do it the other way around, I guess.)\n\n        //Greg Hogg's solution: (better than NeetCode's tbh):\n        //Example: First mid in [3,4,5,6,1,2] is 5.\n        //Then from 5>2 and input being sorted increasing order (not mid/5 because it is already bigger than at least 1 element (2))\n        //=> that there is break in the order somewhere \n        //to the right (the pivot from maximum element to minumum element)\n        //Then, we move left ptr to 6, and similarly, we get l to 1.\n        //Then, since 2 is bigger than 1, it means order is preserverd so no pivot is present.\n        //Therefore, it is somewhere between left to mid (COULD be mid too, because we haven't seen a bigger element here unlike in the first case)\n        \n\n        //At l==r we have our solution because our loop works as follows:\n        // -> every one to the left of it had a smaller element on the right.\n        // -> every one to its right had a number smaller than them on the left.\n        //So, when we get l==r, it meets the above criteria which is the criteria for being a minimum.\n        //To get the max you either do the opposite or return the element before this one.\n        int l = 0, r = nums.Length-1;\n        while(l<r)\n        {\n            int m = l+(r-l)/2;\n            //Console.WriteLine($\"l:{l},r:{r},m:{m},numAtM:{nums[m]},numAtR:{nums[r]}\");\n            if(nums[m]>nums[r]) //it means the pivot is towards the right subarray.\n                l = m+1;\n            else //otherwise, pivot must be in the left subarray.\n                r = m; //m could still be max so we don't -1\n            //The above else block only triggers when number is strictly lesser. This is because the numbers are guaranteed to be unique.\n        }\n        //AT l==r, we have our solution (we can return either nums[l] or nums[r])!\n        return nums[l];\n    }\n\n\n    public int neetCodeBasedSoln(int[] nums)\n    {\n        //After any rotation, the array can have\n        //Left sorted portion and Right sorted portion\n        //Where left sorted portion is the elements that \n        //were orignally towards the end but now \n        //rotation brought them to the left side.\n        //Clearly, our minimum will be somewhere in the right sorted portion.\n        //Next, as long as our nums[mid] has value >= than nums[l],\n        //it means that the minimum must be towards the right (because mid is in right sorted array),\n        //BUT, if nums[mid]<nums[l] (mid is in right sorted array),\n        // it means that either this is minimum, or minimum is to its left.\n        // so we do keep it there and then move right to mid (or mid-1?);\n\n        //Basically, if mid ptr is in right sorted portion, we search to the left. (to find if there's an element smaller than the one at current mid)\n        //else, when mid ptr is in left sorted portion, we search the right. (to find minimum)\n        int l=0,r=nums.Length-1;\n        int min = int.MaxValue;\n        while(l<r)\n        {\n            //It also handles the case where original array was rotated by n, giving back the original sorted array.\n            if(nums[l]<nums[r]) //We are in a sorted subarray. \n                return (int)Math.Min(nums[l],min); //We use min to make sure we haven't seen a smaller value before this (e.g. when subarray between l and r is just the whole left sorted array)\n            int m = (l+r)/2;\n            if(nums[m]>=nums[l]) //We are in left sorted array.\n            {\n                l=m+1; //search right of m to go to the right sorted array.\n            }\n            else //nums[m]<nums[l] => we are in right sorted array.\n            {\n                min = nums[m]; //(int)Math.Min(nums[m], min);\n                r=m-1;//we search to the left of m to go see if there are any elements smaller than this there.\n                //Not that there will never be an element smaller than it to the right because it is a sorted sub array (specifically the right sorted array)\n            }\n            //we gotta handle the edgecase where m==l (which is possible) //Only got this because of NeetCode\n        }\n        return min;\n    }\n}\n",
    "memory": 51180,
    "stdout": "",
    "language": "csharp",
    "time": "0.768",
    "problemId": "find-minimum-in-rotated-sorted-array",
    "stderr": ""
}