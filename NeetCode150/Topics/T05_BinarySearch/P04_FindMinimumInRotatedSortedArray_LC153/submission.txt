1, Accepted
{
    "date": "2024-09-21T23:34:48.882Z",
    "statusDescription": "Accepted",
    "code": "public class Solution {\n    public int FindMin(int[] nums) {\n        //SINCE WE HAVE SORTED INPUT (almost)\n        //AND WE ARE LOOKING FOR AN O(log(n)) solution,\n        //IT MUST BE LOOKING FOR BINARY SEARCH!\n\n        //Greg Hogg's solution (better than NeetCode's)\n        return attempt1(nums);  //READ THE COMMENTS!\n\n        //Check NeetCode's solution as well as that might be useful for other problems as well (e.g. Search in Rotated Sorted Array)\n        \n    }\n    public int attempt1(int[] nums)\n    {\n        //My observations:\n        //Clearly, we can identify max when the next element is smaller than current.\n        //Clearly, the min element will be right after the max one.\n        //(Could also do it the other way around, I guess.)\n\n        //Greg Hogg's solution: (better than NeetCode's tbh):\n        //Example: First mid in [3,4,5,6,1,2] is 5.\n        //Then from 5>2 and input being sorted increasing order (not mid/5 because it is already bigger than at least 1 element (2))\n        //=> that there is break in the order somewhere \n        //to the right (the pivot from maximum element to minumum element)\n        //Then, we move left ptr to 6, and similarly, we get l to 1.\n        //Then, since 2 is bigger than 1, it means order is preserverd so no pivot is present.\n        //Therefore, it is somewhere between left to mid (COULD be mid too, because we haven't seen a bigger element here unlike in the first case)\n        \n\n        //At l==r we have our solution because our loop works as follows:\n        // -> every one to the left of it had a smaller element on the right.\n        // -> every one to its right had a number smaller than them on the left.\n        //So, when we get l==r, it meets the above criteria which is the criteria for being a minimum.\n        //To get the max you either do the opposite or return the element before this one.\n        int l = 0, r = nums.Length-1;\n        while(l<r)\n        {\n            int m = l+(r-l)/2;\n            //Console.WriteLine($\"l:{l},r:{r},m:{m},numAtM:{nums[m]},numAtR:{nums[r]}\");\n            if(nums[m]>nums[r]) //it means the pivot is towards the right subarray.\n                l = m+1;\n            else //otherwise, pivot must be in the left subarray.\n                r = m; //m could still be max so we don't -1\n            //The above else block only triggers when number is strictly lesser. This is because the numbers are guaranteed to be unique.\n        }\n        //AT l==r, we have our solution (we can return either nums[l] or nums[r])!\n        return nums[l];\n\n\n        //OLD TRY:\n        //Clearly, we can identify max when the next element is smaller than current.\n        //Clearly, the min element will be right after the max one.\n        //(Could also do it the other way around, I guess.)\n        //This is to be done via using the modulo (%) operator to avoid going out of bounds of array.\n\n        // int l=0, r=(2*nums.Length)-1; \n        // //^^ SHOUTOUT TO NeetCode'S SHORTS!\n        // // I JUST RANDOMLY REMEMBERED SEEING THIS IN ONE OF HIS VIDEOS AFTER BANGING MY HEAD AGAINST THE WALL FOR 15 MINUTES NOW!\n        // // WE USE THIS TO MIRROR THE ARRAY (alongside the use of a modulo)\n        // // THEN WE CAN PRETEND THAT EVERYTHING IS SORTED BECAUSE DOING THIS WILL GIVE US THE CORRECT ARRAY IN THE MIDDLE OF THE DUPLICATED ARRAY.\n        // //e.g. : [4,1,2,3]+[4,1,2,3] has the correct subarray inside it!\n        // while(l<=r)\n        // {\n        //     int mid = l + (r-l);\n        //     int midPlus1 = (mid+1)%nums.Length;\n        //     if(nums[mid]>nums[midPlus1])\n        //         return nums[midPlus1];\n        //     else(nums[mid]==nums[midPlus1])\n        //     {\n        //         nu\n        //     }\n        // }\n    }\n\n\n    // public int neetCodeBasedSoln(int[] nums)\n    // {\n    //     int l=0,r=(2*nums.Length)-1;\n    //     while(l<r)\n    //     {\n\n    //     }\n    // }\n}\n",
    "memory": 51676,
    "stdout": "",
    "language": "csharp",
    "time": "0.811",
    "problemId": "find-minimum-in-rotated-sorted-array",
    "stderr": ""
}