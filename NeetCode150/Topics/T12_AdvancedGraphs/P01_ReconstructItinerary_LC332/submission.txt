1, Compilation Error
{
    "language": "csharp",
    "code": "public class Solution {\n    public List<string> FindItinerary(List<List<string>> tickets) {\n        //[IMPORTANT!!] PLEASE WATCH THE FOLLOWING FOR BETTER UNDESTANDING:\n        //  [William Fisset (YouTube Channel): \"Eulerian Path/Circuit algorithm (Hierholzer's algorithm) | Graph Theory\"](https://www.youtube.com/watch?v=8MpoO2zA2l4)\n        \n        //Also, read my comments.\n\n\n        //My first thought is topological sort.\n        //NOW THAT I THINK ABOUT IT, THAT PROBABLY WON'T WORK BECAUSE WE WANT TO GET THE ONE WITH MINIMUM LEXOGICAL ORDER.\n        \n        //Watched the Neetcode video of the solution (except the implementation/code part),\n        //and found out that we CAN visit the same node twice, BUT NOT THE SAME EDGE (ticket), so we remove from adjacencyList when done.\n        \n        //READ COMMENTS IN ACTUAL SOLUTION (dfsHierholzersAlgorithm_1)!!\n        return INTENTIONALLY_BREAKING_SO_I_CAN_REWRITE_WITHOUT_KNOWING_IF_CURRENT_ANSWER_IS_CORRECT_dfsHierholzersAlgorithm_1(tickets);\n    }\n\n    Dictionary<string, List<string>> graph; //adjacency list\n    List<string> itnry;\n    const string startingPoint = \"JFK\";\n    \n    List<string> dfsHierholzersAlgorithm_1(List<List<string>> tickets)\n    {\n        //[EXTRA IMPORTANT NOTE] Hierholzer's algorithm basically asks for any nodes with unused edges\n        //after first branch of DFS, what path should we have taken before to include those edges. Whenever all edges have been visited for a node, it means that we haven't left out anything, and as such it can be safely added to the result at the correct position (there's nothing left to visit before it)\n        // - Here, we are guaranteed an itenerary [here, Eulerian path but also works for cycles/circuits (Eulerian circuits/cycles)]\n        //  exists, so we do NOT need to check using `indegree-outdegree <= 1` ONLY AT 1 NODE\n        //  && `outdegree-indegree <= 1` ONLY AT 1 NODE (different from the previous one, obviously).\n        // - We also don't need to maintain a separate outdegree count when using adjacency list because we can just get the list's count.\n        // - PLEASE WATCH THE FOLLOWING FOR BETTER UNDESTANDING:\n        //  [William Fisset (YouTube Channel): \"Eulerian Path/Circuit algorithm (Hierholzer's algorithm) | Graph Theory\"](https://www.youtube.com/watch?v=8MpoO2zA2l4)\n        graph = new();\n        itnry = new();\n        \n        //[EXREMELY_IMPORTANT_NOTE] Two things going on below:\n        // 1. [GREAT_TRICK] Ordering tickets here by destination means the adjacency list we create using it will be ordered correctly.\n        // 2. [GREAT_TRICK] Ordering Descending (in Lexicographical terms) means that we iterate from the end of the list, which not only\n        //      makes it O(1) to remove the element at each level of DFS so we don't consider it anymore in that branch, but also\n        //      makes it O(1) to add elements back at their index (at the end of the list at each level). //Credit to some random LeetCode C# solution I saw.\n        tickets = tickets.OrderByDescending(arr => arr[1]).ToList(); //O(E*log2(E))\n\n\n        foreach(var ticket in tickets) //O(E)\n        {\n            graph.TryAdd(ticket[0], new());\n\n            graph[ticket[0]].Add(ticket[1]);\n        }\n        \n        dfs1(startingPoint); //O(E) because we go through all the edges once (and can visit a vertex multiple times)\n\n        itnry.Reverse(); //O(E) //Since we append airports post-recursion (post-order), the itinerary is built in reverse. Reverse the itinerary list before returning it.\n\n        return itnry;\n    }\n\n    void dfs1(string src) //DFS with Backtracking.\n    {\n        //Due to the sorted neighbor lists in adjList, the itinerary we get the \n        //first time we exhaust all tickets(edges) is the lexicographically smallest and \n        //as such can be returned without needing to compare it with others.\n        while(graph.ContainsKey(src) && graph[src].Count > 0) //also skips this and returns in case of base case (no tickets from here / Final destination? (case 1: there never were any(containskey) case 2: already used up in current branch(graph[cur].Count==0)))\n        {\n            var dest = graph[src][graph[src].Count-1]; //the next lexicographically smallest destination\n            graph[src].RemoveAt(graph[src].Count-1); //Remove `dest` of this iteration from the adjacecny list\n            dfs1(dest);\n            //We don't add back dest to the adjacency list because:\n            //As soon as we can't go back from any branch, we add it to the result \n        }\n        itnry.Add(src);\n\n        //IMPORTANT NOTE: Since we don't care about where we end up after all the flights,\n        // at each airport we are at, we can simply always pick the next to be the\n        // lexicographically smallest one that exists in the list of available destinations\n        // from that airport (using the Adjacency List).\n    }\n    \n}\n",
    "problemId": "reconstruct-flight-path",
    "statusDescription": "Compilation Error",
    "time": "0.0",
    "date": "2024-11-27T22:56:26.095Z",
    "memory": "",
    "stdout": "",
    "stderr": ""
}