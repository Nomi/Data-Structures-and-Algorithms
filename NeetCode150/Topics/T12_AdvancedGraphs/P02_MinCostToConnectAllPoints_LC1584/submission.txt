21, Accepted
{
    "language": "csharp",
    "code": "//## Problem statement Breakdown:\n//GIVEN: An array of DISTINCT points on a 2D graph\n//RESULT: Minimum cost to connect points\n//INPUT: int[][] points, representing the graph, where points[i] == [x,y]\n//OUTPUT: int\n//TO DO: \n//  - Calculate ways to connect all the points such that:\n//      - There's EXACTLY 1 path between 2 points.\n//      - While keeping the manhattan distance (cost) minimum.\n//FACTS: \n//  - cost == |x1 - x2| + |y1 - y2| (maybe this would need to be asked as a clarification in an interview?)\n//CLARIFICATIONS:\n// - Should've asked if it is guaranteed there will be a solution, but as from what I can see, there must be a solution (since all nodes are connected to every other node)\n//CONSTRAINTS:\n// * 1 <= points.length <= 1000\n// * -1000 <= xi, yi <= 1000\n//EXAMPLES:\n// - Input: points = [[0,0],[2,2],[3,3],[2,4],[4,2]]\n// - Output: 10\n\npublic class Solution {\n    IMinCostToConnectPointsCalculator soln;\n    public int MinCostConnectPoints(int[][] points) { //Easy once you know how to do it.\n\n        //[DEPRECATED] Basically shortest path in an undirected AND weighted graph problem, so I'm thinking Djikstra's algorithm (I remember a little bit about it from a video I watched a long time ago)\n        //OKAY, IT MIGHT NOT BE THE CORRECT APPROACH. AT LEAST Neetcodeio solns don't use it.\n        \n        //OKAY, I WAS DUMB, DJIKSTRA IS LOWEST_COST PATH FROM A NODE TO ANOTHER NODE (or all nodes) IN DIRECTED and WEIGHTED GRAPHS \n        //BUT IT DOESN'T ACCOUNT FOR HAVING TO GO THROUGH ALL NODES!!\n        \n        // This problem is ACTUALLY more like finding the Minimum Spanning Tree (MST), \n\n        // Watched the NeetCode Advanced Algorithms course's video about Prim's and Kruskal's (only a little for this one, for now) algorithms for finding MST (without the code examples)\n        \n        // NOTE: Djikstra's, Kruskal's, and Prim's algorithms are greedy algorithms. (I somehow hadn't made the connection yet)\n\n        // What is an MST?\n        //      - Recall that Trees are Acyclical, Connected, & Undirected graphs (well, technically they are directed from parent to child, but that's besides the point).\n        //      - Recall that since a tree are connected and acyclical, for a tree of N nodes, there are N-1 edges (because to connect N points, you need N-1 lines. If you use N lines, you end up with a cycle (e.g. a square has 4 vertices and 4 edges, or two points with two edges between them, or one point with one edge to itself, etc.)).\n        //      - MST is the smallest subset of edges from a graph that still connects all of its nodes but also forms a Tree (Acyclical, Connected, & Undirected Graph as discussed in the point above).\n        //      - If the edges are weighted, then we minimize the total cost by taking a subset of the edges such that the cost is minimized while still satisfying the other conditions of the MST.\n        //          For unweighted, we just assume the weights to be 1 for all edges.\n        //      - There CAN be multiple valid solutions/MSTs (with same cost). We just return 1 of them, like in shortest path algorithms.\n        //      - The result will be one of the valid MSTs but in the form of an edge list.\n        //      - Unlike for Shortest path (where we start from source node), for MST it doesn't matter which node we start from (because all node need to be included anyway).\n        //      - For some Trees (like binary trees) we usually ignore the fact that they're directed (only parent has pointers to its children), but here it is more strict than that. \n        //          Meaning the edges really will not have any direction.\n\n        // Since we want the MST, we can use the following algorithms (read the MST section above first):\n        // NOTE: Djikstra and Prim's are both based on BFS but use PriorityQueue/MinHeap instead of Queue.\n        // NOTE2: Read the note about Djikstra vs Prim in my solution for the 'Network Delay Time' problem.\n        //  * Prim's Algorithm: [for Undirected & Connected Graphs] \n        //      - We use a `visited` HashSet because we don't want to visit a node more than once,\n        //          because that would lead to a cycle.\n        //      - We also use a MinHeap<weight, n1, n2>, which sorts based on weight/cost of the edges\n        //          because we want to pop/dequeue the minimum weight/cost edges first. (where n1 and n2 are the nodes for the edges)\n        //      - We start at ANY node and add its edges to the MinHeap AND add the node to the Visited set.\n        //      - Then keep iterating and for the current edge for each iteration, use the n2 as the node\n        //          and take all neighbors of the current node and add its edges them to the MinHeap (alongside their total weights (combined with how much it took get there))\n        //      - { At this point, the algorithm works almost exactly like Djikstra's algorithm. (Side note: I watched the video about the algorithm from NeetCode's Advanced Graphs course but the problem for it on NC150 comes after this one (without the code example).) }\n        //      - { Also, we could run the algorithm to keep the loop running until the MinHeap is empty, but we could also add a different condition to continue the algorithm\n        //          to avoid extra processing once we're done finding it. For example:\n        //              1. Run until MinHeap empty (as we discussed above, this is a little inefficient but it works)\n        //              2. Run while Visited.Count < numOfNodes (if we know what the numOfNodes is),\n        //              3. While number/count of edges in list of edges in our results is < n-1 (as we discussed above, it being n-1 means we're done).\n        //          Just remember that visited.Count is number of nodes processed thus far, and result.Count is number of edges thus far.\n        //          To keep it simple, we will run until MinHeap is empty. }\n        //      - By the way, while the edges are undirected, the order we put n1 and n2 in the MinHeap\n        //          matters because that's the direction of our traversal (not the edge) [where n1 is where we are at, and n2 is where we will go] \n        //          and reversing it suddenly would just lead to going back to previous nodes.\n        //      - If there are equal weights at some point, we can pop any of those and still get a valid MST (no cycle and minimum cost) \n        //          because as discussed earlier, there can be many valid solution, and this will be one of them.\n        //      - Since the algorithm is so similar to Dikstra's alogirthm, the complexities are the same:\n        //          * TC: O(E*log2(E)) where E <= V^2 (E==V^2 when every node is connected to every other node)\n        //              [Also, O(E*log2(v^2)) == O(E*2*log2(v)) == O(E*log2(v))]\n        //              (Note: E*log2(E) comes from adding AT MOST E edges to the MinHeap)\n        //          * SC: O(E) where E<=V^2 (E==V^2 when every node is connected to every other node)\n        //              [because we only store Edges]\n        //      - Watch the video about this algorithm from the NeetCode Advanced Algorithms \n        //          course to find WHY this algorithm works and get more details about it.\n        //      - Note, MinHeap is also called `Frontier`? Also, in some rare cases, due to our input's properties (and further processing), we might not end up needing the MinHeap.\n        //\n        //              \n        //  * Kruskal's Algorithm:\n        //      - Just another way to find the MST of a connected graph.\n        //      - Maybe if Prim's algorithm is too confusing for you, you might prefer Kruskal's algorithm.\n        //      - In fact, in NeetCode's opinion, it is conceptually it is a much easier algorithm to understand.\n        //      - BUT, coding it might actually be more difficult/complicated because it uses the Union Find datastructure (which you might also need to implement yourself) and the implementation even if Union Find were to be given might be at least somewhat difficult/complicated.\n        //      - Due to above reason, I stopped learning this, at least for now, because I have limited time and clearly this doesn't seem to be worth it given the tight schedule for my upcoming interview.\n        //      - Before fully stopping, I did watch the video at least upto the point where the basic logic is and why it works is explained and makes sense (without code) [~6:45 mark] (e.g. how to avoid introducing cycles by using Find to check if the edge we're using connects nodes in the same component), but not worth typing it out if I am not fully commited to practicing/using it yet.\n        //      - Oh, and Neecode's video about this problem also mentions that Prim's algo is also usualy more efficient.\n\n        soln = new PrimsAlgo_1();\n\n        return soln.MinCostConnectPoints(points);\n    }\n\n}\n\n\npublic interface IMinCostToConnectPointsCalculator\n{\n    int MinCostConnectPoints(int[][] points);\n}\n\npublic class PrimsAlgo_1 : IMinCostToConnectPointsCalculator\n{\n    int Abs(int num) => (int) Math.Abs(num);\n    int Cost(int x1, int y1, int x2, int y2) => Abs(x1-x2) + Abs(y1-y2); //returns ManhattanCost\n\n    public int MinCostConnectPoints(int[][] points) //Note: Watched NC video for this and somehow I ended up doing this while sneaking peeks at the NC150 solution.\n    {\n        //[IMPORTANT OBSERVATION!] Since any point can be conneccted to any other point, we can consider it as a FULLY CONNECTED graph.  //ALSO IT IS UNDIRECTED!!!\n        //      => We will have N^2 edges in total\n        //We want to find a MST of this graph because that will be (one of) our solution.\n\n        //Step 1- Build Adjacency List        \n        var neighbors = new Dictionary<int, List<(int cost, int ptIdx)>>(points.Length);\n\n        for(int i=0; i<points.Length; i++)\n        {\n            int x1 = points[i][0], y1 = points[i][1];\n            neighbors.TryAdd(i, new());\n            for(int j = i+1 ; j < points.Length; j++) //[IMPORTANT!!] [ALMOST_FORGOT!!] `j=i+1` because we would have paired the current i with all the nodes before it (and we don't pair it with itself). Obviously!\n            {\n                int cost = Cost(x1, y1, points[j][0], points[j][1]);\n                neighbors[i].Add((cost, j));\n                \n                neighbors.TryAdd(j, new());\n                neighbors[j].Add((cost, i));\n                //We add both because it is undirected (or technically one undirected edge is two directed edges just in opposite direction)\n            }\n\n        }\n\n        \n        //Step 2- Use Prim's algorithm (standard) to get MST (apparently there's an optimal version which is more efficient. Check Neetcodeio solns. I'm skipping them for now.)\n        int minCost = 0;\n        HashSet<int> visited = new(points.Length); //For avoiding nodes we already visited..\n\n        PriorityQueue<(int cost, int ptIdx), int> pq = new(); //For Prim's algo.\n        pq.Enqueue((0, 0), 0); //since we can start at any node in Prim's algo, let's start at the first point.\n\n        while(visited.Count < points.Length && pq.Count>0)\n        {\n            var cur = pq.Dequeue();\n\n            if(visited.Contains(cur.ptIdx))\n                continue; //skip\n            visited.Add(cur.ptIdx);\n\n            minCost += cur.cost;\n            //\n            foreach(var neighbor in neighbors[cur.ptIdx])  //If it were not a fully connected graph, it might have helped to have this loop inside an `if (adj.ContainsKey(i))` condition to avoid sorting and going through empty nodes.\n            {\n                pq.Enqueue(neighbor, neighbor.cost);\n            }\n        }\n\n        return visited.Count == points.Length ? minCost : -1;\n    }\n}",
    "problemId": "min-cost-to-connect-points",
    "statusDescription": "Accepted",
    "time": "0.417",
    "date": "2024-11-29T22:41:18.426Z",
    "memory": 56360,
    "stdout": "",
    "stderr": ""
}