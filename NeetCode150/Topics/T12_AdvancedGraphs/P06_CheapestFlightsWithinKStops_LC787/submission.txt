7, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    //[VERY IMPORTANT] USE THE FOLLOWING RESOURCES:\n    // - [IMP!!] WATCH NEETCODE VIDEO FOR THIS PROBLEM\n    // - [V. IMP!!] READ MY SOLUTION FOR THIS PROBLEM\n    // - [\"Bellman Ford Algorithm | Shortest path & Negative cycles | Graph Theory\" by \"WilliamFiset\"](https://www.youtube.com/watch?v=lyw4FaxrwHg)\n    //      * Comment on the video : We need to run V-1 times because we run edges in random order so we could run from the vertex has positive infinity cost to another vertex also has positive infinity cost. So we could reduce time complexity if we run edges in an order that assures unvisited vertex will be visited from visited vertex, right?\n    //          + Author's reply: Only in the worst case does it take V-1 iterations for the Bellman-Ford algorithm to complete. Another stopping condition is when we're unable to relax an edge, this means we have reached the optimal solution early. In practice, this optimization works very well from tests I've conducted in the past. See here for an example: https://github.com/williamfiset/Algorithms/blob/master/src/main/java/com/williamfiset/algorithms/graphtheory/BellmanFordEdgeList.java#L42\n    //      * Another comment: To elaborate on why we do \"V-1\" iterations, it comes from the following lemma: \"if the shortest path from the source to a node v ends with the edge u->v, and we already know the correct distance to u, and then we relax the edge u->v, we will find the correct distance to v\". It is a pretty obvious lemma, if you think about it, but the correctness of Bellman-Ford, Dijkstra, and topological sort are all based on it. The consequence of this lemma is that, in order to find the correct distance to a node v, we need to relax all the edges in the shortest path from the source to v *IN ORDER*. Dijkstra and topological sort are efficient because we only relax the out-going edges from each node after we found the correct distance for that node, so we only need to relax the edges once. Unfortunately, the combination of cycles and negative edges makes it impossible to find a \"good\" order to relax the edges. Thus, Bellman-Ford just relaxes all the edges in an arbitrary order (this is one iteration of Bellman-Ford). In the first iteration, we find the correct distance for all the nodes whose shortest paths from the source have 1 edge. In the next iteration, we find the correct distances for all the nodes whose shortest paths from the source have 2 edges, and so on. If the shortest path with the most edges has k edges, we need k iterations of Bellman Ford. Of course, we do not know what \"k\" is in advance, but, since shortest paths never repeat nodes (assuming there are no negative cycles), what we know for sure is that any shortest path will have at most V-1 edges (in the case where it goes through every node). This is why V-1 iterations is ALWAYS enough, but often not necessary. If in one iteration of Bellman-Ford no relaxation yields any improvement, it means that we already found all shortest paths and we can finish.\n    // - https://stackoverflow.com/questions/12782431/relaxation-of-an-edge-in-dijkstras-algorithm\n    // - ['Bellman-Ford in 5 minutes \u2014 Step by step example' by 'Michael Sambol'](https://www.youtube.com/watch?v=obWXjtg0L64)\n    // - ['Bellman-Ford in 4 minutes \u2014 Theory' by 'Michael Sambol'](https://www.youtube.com/watch?v=9PHkk0UavIM)\n    // - ['Graph Algorithms' article on University of Washington website](https://courses.cs.washington.edu/courses/cse373/23au/lessons/graph-algorithms/) Good for general cases.\n    // - Time complexity of BF is generally O(V*E), but since here we only go from any node at most k times t\n    // - While Dijkstra is more efficient generally, we should use Bellman Ford's algorithm when: \n    //      * It is more efficient and easier for problems like this (where you need at most k steps). \n    //      * When there are NEGATIVE WEIGHTS\n    //      * Can detect negative cycles and determine where they exist. (especially useful for finance in arbitrage)\n    //      * Doesn't use visited node to keep track, in fact each vertex is considered multiple times ?\n    //      * It goes through every single edge in the graph\n    //      * Note that BF uses edge list.\n\n    //[IMPORTANT] THIS IS A SPECIAL CASE BECAUSE WE HAVE TO CONSTRAINTS: (compared to normal dijkstra problem)\n    //  - CHEAPEST FLIGHTS (meaning SPT algo)\n    //  - LESS THAN K STOPS ( this and above means we use Bellman Ford)\n    //  - We can't use `visited` HashSet to avoid infinite loop here because\n    //      we might want to visit a node multiple times through different paths.\n    //  - We should use Bellman Ford's algorithm for this. \n    //      * It is more efficient and easier for problems like this (where you need at most k steps). \n    //      * It even supports negative weights.\n    public int FindCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        //Since it says AT MOST k steps, it means we want the Shortest Path (by weight), and not an MST.\n\n        //ACTUALLY, We should USE Bellman Ford's algorithm for this. \n        //      * It is more efficient and easier for problems like this. \n        //      * It even supports negative weights.\n        // Bellman Ford Algorithm does V-1 iterations (where V is number of nodes/vertices)\n        return BellmanFordAlgo1(n, flights, src, dst, k);\n\n        // //I DID THIS WRONG AT FIRST BECAUSE I JUST USED THE NORMAL DIJKSTRA WITH JUST THE STOPS BEING PASSED.\n        // //FOR THIS APPROACH, I READ THROUGH THE NEETCODEIO SOLN, BUT I FELT PRETTY SLEEPY TOWARDS THE END SO I'M NOT SURE I FULLY UNDERSTAND.\n        // //I WILL WATCH THE NEETCODE VIDEO NOW, JUST TO MAKE SURE I UNDERSTAND.\n        // return Dijkstra1(n, flights, src, dst, k);\n    }\n\n\n\n    int BellmanFordAlgo1(int n, int[][] flights, int src, int dst, int k) //TC: O(n+(m\u2217k)) //SC: O(n) Where n n is the number of flights, m m is the number of edges and k k is the number of stops.\n    {\n        //SC: O(V)\n        //Should've named it `costAtPrevLevel` maybe????\n        int[] costAtCurLevel = new int[n]; //Minimum Cost to get to the index node at current level. Level is the length of the chain of nodes/edges we traverse (=> level = number of nodes we can cover travel from source ).\n        Array.Fill(costAtCurLevel, int.MaxValue); //When level is 0 (chain of 0 edges allowed between any two nodes), we cannot reach any node except staying at the source node.\n        costAtCurLevel[src] = 0; //Cost of staying where we are == 0\n        \n        //TC: O(K*(V+E))\n        // Now, let's find cost at each i-th level. Note that we go upto k+1-th level because we k is number of stops/nodes between (src, dst). So, k+1th node would be dst and src is the 0th level/node. \n        for(int i = 1; i<k+2; i++) //I assume we start from 1 (turns out can also do [0,k+1)). Because we already manually filled the cost array for 0-th level (only src node visited with 0 nodes used between getting from src node to itself)\n        {   \n            //costAtCurLevel is the (i-1)thLevelCost here.\n            int[] ithLevelCost = costAtCurLevel.ToArray(); //O(V) //Clones array //Neetcodeio soln does: (int[])prices.Clone(); // In short: Used to ensure the updates do not affect the decision-making for the current iteration.\n            foreach(var flt in flights) //O(E)\n            {\n                var fltSrc = flt[0];\n                if(costAtCurLevel[fltSrc] == int.MaxValue) //Skip nodes we don't know the cost of getting to from the i-1'th level. This is how we limit our level, because we want to only i+1th level nodes, which would mean nodes that are connected to nodes we reached on the (i-1)-th level.\n                    continue;\n                    \n                var fltDst = flt[1];\n                var fltCst = flt[2];\n                var totalCst = costAtCurLevel[fltSrc] + fltCst;\n                \n                if(totalCst < ithLevelCost[fltDst]) //IMPORTANT!! : I HAD `if(totalCst < costAtCurLevel[fltDst])` earlier, but that's wrong because if we had found a smaller solution than the current totalCst in via a prior flt, we would end up overwriting it! \n                    ithLevelCost[fltDst] = totalCst;    // The following comment is what I was thinking when I made the above mistake. I was dumb : //[DEPRECATED / INCORRECT] This is (the rest of) how we limit our level to the i-th level. If we modify the costAtCurLevel for a node we encounter in the future (of the outer loop) as a source, then setting it would break the logic we use to skip if the we never visited the fltSrc at the (i-1)th level. Because then the array we use to check that would have the cost from i-th level, and the calculation then would give us the i+1th level instead of the i-th level.\n            }\n\n            costAtCurLevel = ithLevelCost; //Now costAtCurLevel has the cost at the K-th level. Keep in mind we need cost at K+1-th level because we need to get to dst which would be k+1th node/stop if there were k stops between it and src (and src would be 0th stop)\n        }\n\n        return costAtCurLevel[dst] != int.MaxValue ? costAtCurLevel[dst] : -1; //-1 => Not found\n    }\n\n\n    //[IMPORTANT] THIS IS A SPECIAL CASE BECAUSE WE HAVE TO CONSTRAINTS: \n    //  - CHEAPEST FLIGHTS (meaning dijkstra shortest path over this as weight)\n    //  - LESS THAN K STOPS (meaning you have to check more than one / just the \n    //      lowest cost path)\n    //  - We can't use `visited` HashSet to avoid infinite loop here because\n    //      we might want to visit a node multiple times through different paths.\n    //  - We still want to keep it greedy via dijkstra, so minheap over cost stays.\n    //  - We can use a cost[{dstNode}][{numberOfStops}] array where for each node\n    //      we keep track of if we have been there with this number of stops before,\n    //      if not, we do as if it wasn't in visited. BUT if it isn't, we check if \n    //      the current cost we reached it with was lesser than the one we reached \n    //      it with previously (compare cur.cost to value of the cost array with appropriate indexes),\n    //      and if it is lesser, then we do as if it wasn't in visited. But, if it\n    //      is greater, we continue as if it was in visited and skip adding any of \n    //      its neighbors to the priority queue.\n    //[NOTE] I WROTE THIS STUFF JUST BASED ON NEETCODEIO SOLN. PLEASE WATCH HIS VIDEO\n    //too. I know I will right now.\n    int Dijkstra1(int n, int[][] flights, int src, int dst, int k) //TC: O((n+m)\u2217k) //SC: O(n\u2217k) Where n n is the number of flights, m m is the number of edges and k k is the number of stops.\n    {\n        // JUST WATCH THE NEETCODE VIDEO (and read the comment next to the ocst array)\n\n        //Conditions imply no cycles.\n        // The fact that we have another constraint (for k) means...\n        \n        var cost = new int[n][]; //READ FULLY: JUST CHECKED THE NEETCODEIO SOLN AND WATCHED NEETCODE VIDEO AND REALIZED WE NEED THIS INSTEAD OF VISITED TO ENSURE THAT WE CAN CHECK IF EACH NODE HAS BEEN VISITED AFTER THIS MANY STOPS (and with what cost)\n        List<List<(int cost, int dst)>> neighbors = new(n);\n        for(int i=0; i<n;i++) //O(n*k)\n        {\n            cost[i] = new int[k+2]; //+2 because first step is src and last is node, the STOPS we want are inbetween.\n            Array.Fill(cost[i], int.MaxValue);\n            neighbors.Add(new());\n        }\n\n        foreach(var flight in flights)\n        {\n            neighbors[flight[0]].Add((flight[2], flight[1]));\n        }\n\n        // HashSet<int> visited = new();\n        cost[src][0] = 0; //<=> cost from src to src at 0 steps is 0.\n        PriorityQueue<(int cost, int dst, int stops), int> minHeap = new();\n        minHeap.Enqueue((0, src, 0), 0);\n        while(minHeap.Count>0)\n        {\n            var cur = minHeap.Dequeue();\n            if(cur.dst == dst) //ORDER MATTERS! I think...\n                return cur.cost;\n            // if(visited.Contains(cur.dst))\n            //     continue;\n            // visited.Add(cur.dst);\n            \n            if(cur.stops == k+1) //order of this matters because dst is allowed to be k+1th because technically only the stops inbetween src and dst count. //Basically, we put this after checking whether current node is destination.\n                continue;\n\n            // if(!neighbors.ContainsKey(cur.dst)) \n            //     continue;\n\n            foreach(var nei in neighbors[cur.dst])\n            {\n                var newCost = cur.cost+nei.cost;\n                var newStops = cur.stops+1;\n                if(cost[nei.dst][newStops] > newCost)\n                {\n                    //this condition acts somewhat like visited set due to initially being \n                    //set to int.MaxValue:\n                    // - Ensures we calculate shortest path from the neighbor nei at least once \n                    //      for all different number of steps (<=k) we get to the nei with. \n                    //      (the <= k condition is maintained by one of the if conditions above).\n                    // - Ensures we ONLY calculate shortest path for same number of steps at \n                    //      nei again if the new cost is lower than previous one.\n                    cost[nei.dst][newStops] = newCost;\n                    minHeap.Enqueue((newCost, nei.dst, newStops), newCost);\n                }\n            }\n        }\n\n        return -1;\n    }\n}\n",
    "problemId": "cheapest-flight-path",
    "statusDescription": "Accepted",
    "time": "0.409",
    "date": "2024-11-30T15:01:38.116Z",
    "memory": 56232,
    "stdout": "",
    "stderr": ""
}