1, Accepted
{
    "date": "2024-09-16T21:28:53.727Z",
    "statusDescription": "Accepted",
    "code": "public class Solution {\n    public int[] MaxSlidingWindow(int[] nums, int k) {\n        //Number of windows is obviously = 1+nums.Count()-k\n        int[] output = new int[nums.Count()-k+1];\n        var q = new LinkedList<int>();\n        int l=0, r=0;\n        int windowIdx=0;\n        while(r<nums.Length)\n        {\n            //We check and remove from last because\n            //e.g. the first element(maximum) is equal to the new \n            //element, so to keep position correct, we remove \n            //every value we met after that \n            //      (all smaller to it, and if there's\n            //      another duplicate, those will be \n            //      right at the beginning because it has to \n            //      be max number by definition of monotonically\n            //      increasing queue.)\n            // and then later add the next instance of that number\n            // to the deque. If new number is greater, then we\n            // can just empty the dequeue (simulated by Linkedlist);\n            while(q.Count!=0&&q.Last.Value<nums[r]) //To keep it a monotonically decreasing queue, we remove all elements smaller than this.\n                q.RemoveLast();\n            //Add last because nums[r] can possibly be:\n            // 1. equal to first/largest element, in which case order doesn't matter (we cleared out any smaller numbers before it already).\n            // 2. was bigger than the earlier largest element, which was removed earlier. (queue is empty).\n            // 3. smaller, in which case we need to add it at end to keep monotonically increasing nature.\n            q.AddLast(nums[r]);\n            if(r-l+1==k) //Window is complete\n            {\n                //Note that first element of q is the \n                //largest element in this window.\n\n                output[windowIdx]=q.First.Value;\n                if(nums[l]==q.First.Value) //if the first element of the window (i.e. at nums[l]) is the same as the number we just removed, it is guaranteed to be that element and not affect any further calculations because even if we encounter a duplicate after that, we have stored them directly after it.\n                    q.RemoveFirst();\n                l++;\n                windowIdx++;\n            }\n            r++;\n        }\n        return output;\n    }\n}\n",
    "memory": 54596,
    "stdout": "",
    "language": "csharp",
    "time": "0.783",
    "problemId": "sliding-window-maximum",
    "stderr": ""
}