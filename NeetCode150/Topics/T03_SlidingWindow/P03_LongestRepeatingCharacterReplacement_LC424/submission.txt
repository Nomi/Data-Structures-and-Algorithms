1, Accepted
{
    "date": "2024-09-15T23:52:48.026Z",
    "statusDescription": "Accepted",
    "code": "public class Solution {\n    public int CharacterReplacement(string s, int k) {\n        //Used NeetCode's video \n        //to speed my progress because I was stuck without \n        //much of an idea!:\n        // return attempt1OverEngineered(s,k); \n        \n\n        //More realistic and the MAIN way of doing it for me? Maybe?\n        return attempt2Realistic(s,k);\n    }\n    // public void fillArr(T[] arr, T val)\n    // {\n    //     for(int i=0;i<arr.Count();i++)\n    //     {\n    //         arr[i] = val;\n    //     }\n    // }\n\n\n    //OverEngineered variant\n    //TC: O(N)\n    //SC: O(1)\n    //NOTE: This only works because not decrementing maxFreq\n    // does not affect the result because in order to have\n    // a better max result (window length), we need more\n    // elements of the same kind (=> bigger maxFreq) to\n    // ensure we have bigger window while having same/constant\n    // replacements. \n    public int attempt1OverEngineered(string s, int k) //based on second part of neetcode's solution\n    {\n        if(s.Length<2)\n            return s.Length;\n        \n        int[] charFreq = new int[26]; //initialized to 0s by default.\n        //Used NeetCode's video (shortform) to speed my progress because I was stuck without much of an idea!\n        \n        int maxLen = 0;\n        int l=0;\n        int maxFreq = 0;\n        for(int r=0;r<s.Length;r++)\n        {\n            charFreq[s[r]-'A']++;\n            if(charFreq[s[r]-'A']>maxFreq)\n                maxFreq = charFreq[s[r]-'A'];\n            \n            int lettersToChange = (r-l+1) - maxFreq;\n            if(lettersToChange>k)\n            {\n                charFreq[s[l]-'A']--;\n                l++;\n            }\n            if((r-l+1)>maxLen)//because of needing to include right\n                maxLen=(r-l+1);\n        }\n        return maxLen;\n        ////My previous attempt:\n        // while(r<s.Length)\n        // {\n        //     if(++charFreq[s[r]-'A']>maxFreq)\n        //         maxFreq = charFreq[s[r]-'A'];\n        //     //r-l == window length (sliding window)\n        //     //window length - maxFreq == number of characters to replace.\n        //     while(r<s.Length&&k>r-l-maxFreq)\n        //     {\n        //         r++;\n        //         if(++charFreq[s[r]-'A']>maxFreq)\n        //             maxFreq = charFreq[s[r]-'A'];\n        //     }\n        //     if(r-l>maxLen)\n        //         maxLen = r-l;\n        //     while()\n        //     {\n        //         //\n        //         if\n        //         l++;\n        //     }\n        // }\n    }\n\n    //Realistic algorithm\n    //TC: O(N)  //O(26*N) but asymptotically bounded by O(N) //i.e. there exists another line (cuz linear) that is higher than it for all input sizes.\n    //SC: O(1)\n    public int attempt2Realistic(string s, int k) \n    {\n        var freq = new int[26]; //initialized to 0 by default C# behavior.\n        int maxLen=0;\n        int l = 0;\n        for(int r=0;r<s.Length;r++) //NOTE freq.Max() = O(26) cuz it always contains 26 elements.\n        {\n            freq[s[r]-'A']++;\n            //freq.Max() is equivalent to the following: (this is what I was trying before)\n            // int maxFreq = 0;\n            // for(int i=0;i<26;i++)\n            // {\n            //     if(maxFreq<freq[i])\n            //         maxFreq=freq[i];\n            // }\n            \n            int windowLength = r-l+1; //+1 for including r itself.\n            int lettersToReplace = windowLength - freq.Max(); // == number of occurences of any character other than the one with max freq.\n            while((r-l+1-freq.Max())>k) //while because there may be max frequent element at front, which would make an if statement ineffective at decreasing number of replacements.\n            {\n                freq[s[l]-'A']--;\n                l++;\n                windowLength--; //obviously the same as recalculating via r-l+1; cuz we just incremented l so it'd be r-(l+1)+1==r-l-1+1\n                lettersToReplace = windowLength-freq.Max();\n            }\n            \n            if(windowLength>maxLen)\n                maxLen=windowLength;\n        }\n        return maxLen;\n    }\n}",
    "memory": 54320,
    "stdout": "",
    "language": "csharp",
    "time": "0.759",
    "problemId": "longest-repeating-substring-with-replacement",
    "stderr": ""
}