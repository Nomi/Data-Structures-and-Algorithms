6, Accepted
{
    "date": "2024-09-14T17:27:17.870Z",
    "statusDescription": "Accepted",
    "code": "public class Solution {\n    //WHERE MY BUCKET SORT (frequency based buckets) AT????\n\n    //Bruteforce: TC = O(nlog(n))\n    //\n    //MaxHeap: TC = O(n+klog(n)) (at the end you just pop k times after heapifying in linear time using heapify)\n    //         SC = O(n)=O(n)\n    //\n    //MinHeap(best SC): \n    //         TC = O(nlog(k)), where n is the number of elements in nums \n    //         SC = O(k)\n    //BucketSort(best TC):  \n    //             TC= O(n)\n    //             SC = O(n) \n    //FUCK QUICKSELECT, BUCKETSORT BETTER\n    public int[] TopKFrequent(int[] nums, int k) {\n        //INSTEAD OF MINHEAP WE USE BUCKETSORT (not even LeetCode's stupid quickselect can beat it)\n\n        //return BucketSort(nums, k);\n        // return MinHeapAttempt(nums, k);\n        ///* can also do maxheap, which will decrease time complexity when used with heapify (heapify is O(N) when we the data is pre-existing) so we can just pop k elements. */\n        ///* minheap decreases the spacecomplexity by making sure there's only at most k elements in the heap at any given time. */\n\n\n        // ===== PRACTICE FROM HERE: =====\n        // return bs2(nums,k);\n        return mh2(nums,k); //THIS one doesnt need tuples (as compared to other minheap version!) //but might be a tiny bit slower because of adding 1 more element than the other version?\n\n    }\n\n    // public int[] BucketSort(int[] nums, int k)\n    // {\n    //     List<int>[] freqToNums = new List<int>[nums.Count()+1]; //+1 as the biggest frequency is nums.Count() itself (because possible frequencies are IN [0,nums.Count()])!\n    //     var freqMap = new Dictionary<int,int>();\n    //     foreach(var num in nums)\n    //     {\n    //         freqMap.TryAdd(num,0);\n    //         freqMap[num]++;\n    //     }\n    //     foreach(var key in freqMap.Keys) //key is the value\n    //     {\n    //         if(freqToNums[freqMap[key]]==null)\n    //             freqToNums[freqMap[key]]=new();\n    //         freqToNums[freqMap[key]].Add(key);\n    //     }\n    //     int countAdded = 0;\n    //     int[] res = new int[k];\n    //     for(int i=freqToNums.Count()-1;i>=0&&countAdded<k;i--)\n    //     {\n    //         for(int j=0;freqToNums[i]!=null&&j<freqToNums[i].Count&&countAdded<k;j++)\n    //         {\n    //             res[countAdded]=(freqToNums[i][j]);\n    //             countAdded++;\n    //         }\n    //     }\n    //     return res;\n    // }\n    // public int[] QuickSelect(int[] nums, int k)\n    // {\n\n    // }\n\n    // public int[] MinHeapAttempt(int[] nums, int k)\n    // {\n    //     // var minHeap = new PriorityQueue<Tuple<int,int>>(Comparer<Tuple<int,int>>.Create((a,b)=>b.Item2-a.Item2)); \n    //     var minHeap = new PriorityQueue<Tuple<int,int>,int>(Comparer<int>.Create((a,b)=>a-b));\n    //     var freqMap = new Dictionary<int,int>();\n    //     foreach(var num in nums)\n    //     {\n    //         freqMap.TryAdd(num,0);\n    //         freqMap[num]++;\n    //     }\n    //     foreach(var key in freqMap.Keys)\n    //     {\n    //         if(minHeap.Count==k)\n    //         {\n    //             if(minHeap.Peek().Item2<freqMap[key])\n    //                 minHeap.Dequeue();\n    //             else\n    //                 continue;\n    //         }\n    //         minHeap.Enqueue(Tuple.Create(key,freqMap[key]), freqMap[key]);\n    //     }\n    //     var res = new int[minHeap.Count];\n    //     int i=0;\n    //     while(minHeap.Count>0)\n    //     {\n    //         res[i]=minHeap.Dequeue().Item1;\n    //         i++;\n    //     }\n    //     return res;\n    // }\n\n\n    public int[] bs2(int[] nums, int k) \n    {\n        int maxFreq = nums.Count(); //max possible frequency (when array only has 1 element)\n        List<int>[] freqBuckets = new List<int>[maxFreq+1]; //+1 is for 0 frequency, which technically isn't needed, but makes indexing easier.\n        Dictionary<int, int> numToFreq = new();\n        foreach(var num in nums)\n        {\n            numToFreq.TryAdd(num,0);\n            numToFreq[num]++;\n        }\n        foreach(var num in numToFreq.Keys)\n        {\n            if(freqBuckets[numToFreq[num]]==null)\n                freqBuckets[numToFreq[num]]=new();\n            freqBuckets[numToFreq[num]].Add(num);\n        }\n        var result = new int[k];\n        int count = 0;\n        for(int i=freqBuckets.Count()-1;i>=0&&count<k;i--)\n        {\n            if(freqBuckets[i]==null)\n                continue;\n            foreach(var num in freqBuckets[i])\n            {\n                result[count]=num;\n                count++;\n                if(count==k)\n                    break;\n            }\n        }\n        return result;\n    }\n\n    public int[] mh2(int[] nums, int k) //This one doesn't need tuples!! //but might be a tiny bit slower because of adding 1 more element than the other version?\n    {\n        var minHeap = new PriorityQueue<int,int>(Comparer<int>.Create((a,b)=>a-b));\n       \n        var freqMap = new Dictionary<int,int>();\n        for(int i = 0; i<nums.Count();i++)\n        {\n            freqMap.TryAdd(nums[i],0);\n            freqMap[nums[i]]++;\n        }\n        \n        foreach(var elem in freqMap)\n        {\n            minHeap.Enqueue(elem.Key,elem.Value);\n            if(minHeap.Count>k)\n                minHeap.Dequeue();\n        }\n\n        var result = new int[k];\n        int count = 0;\n        while(minHeap.Count>0)\n        {\n            result[count] = minHeap.Dequeue();\n            count++;\n        }\n        return result;\n    }\n}\n",
    "memory": 52996,
    "stdout": "",
    "language": "csharp",
    "time": "0.917",
    "problemId": "top-k-elements-in-list",
    "stderr": ""
}