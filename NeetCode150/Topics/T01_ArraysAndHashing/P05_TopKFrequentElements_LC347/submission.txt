3, Accepted
{
    "date": "2024-09-03T21:58:59.029Z",
    "statusDescription": "Accepted",
    "code": "public class Solution {\n    //WHERE MY BUCKET SORT (frequency based buckets) AT????\n\n    //Bruteforce: TC = O(nlog(n))\n    //\n    //MaxHeap: TC = O(n+klog(n)) (at the end you just pop k times after heapifying in linear time using heapify)\n    //         SC = O(n+n)=O(n)\n    //\n    //MinHeap: TC = O(nlog(k)), where n is the number of elements in nums \n    //         SC = O(n + k)\n    //BucketSort:  TC= O(n)\n    //             SC = O(n) \n    //FUCK QUICKSELECT, BUCKETSORT BETTER\n    public int[] TopKFrequent(int[] nums, int k) {\n        //INSTEAD OF MINHEAP WE USE BUCKETSORT (not even LeetCode's stupid quickselect can beat it)\n\n        return BucketSort(nums, k);\n        // return MinHeapAttempt(nums, k);\n        ///* can also do maxheap, which will decrease time complexity when used with heapify (heapify is O(N) when we the data is pre-existing) so we can just pop k elements. */\n        ///* minheap decreases the spacecomplexity by making sure there's only at most k elements in the heap at any given time. */\n    }\n\n    public int[] BucketSort(int[] nums, int k)\n    {\n        List<int>[] freqToNums = new List<int>[nums.Count()+1]; //+1 for 0 (because possible frequencies are IN [0,nums.Count()])!\n        var freqMap = new Dictionary<int,int>();\n        foreach(var num in nums)\n        {\n            freqMap.TryAdd(num,0);\n            freqMap[num]++;\n        }\n        foreach(var key in freqMap.Keys) //key is the value\n        {\n            if(freqToNums[freqMap[key]]==null)\n                freqToNums[freqMap[key]]=new();\n            freqToNums[freqMap[key]].Add(key);\n        }\n        int countAdded = 0;\n        int[] res = new int[k];\n        for(int i=freqToNums.Count()-1;i>=0&&countAdded<k;i--)\n        {\n            for(int j=0;freqToNums[i]!=null&&j<freqToNums[i].Count&&countAdded<k;j++)\n            {\n                res[countAdded]=(freqToNums[i][j]);\n                countAdded++;\n            }\n        }\n        return res;\n    }\n    // public int[] QuickSelect(int[] nums, int k)\n    // {\n\n    // }\n\n    // public int[] MinHeapAttempt(int[] nums, int k)\n    // {\n    //     // var minHeap = new PriorityQueue<Tuple<int,int>>(Comparer<Tuple<int,int>>.Create((a,b)=>b.Item2-a.Item2)); \n    //     var minHeap = new PriorityQueue<Tuple<int,int>,int>(Comparer<int>.Create((a,b)=>a-b));\n    //     var freqMap = new Dictionary<int,int>();\n    //     foreach(var num in nums)\n    //     {\n    //         freqMap.TryAdd(num,0);\n    //         freqMap[num]++;\n    //     }\n    //     foreach(var key in freqMap.Keys)\n    //     {\n    //         if(minHeap.Count==k)\n    //         {\n    //             if(minHeap.Peek().Item2<freqMap[key])\n    //                 minHeap.Dequeue();\n    //             else\n    //                 continue;\n    //         }\n    //         minHeap.Enqueue(Tuple.Create(key,freqMap[key]), freqMap[key]);\n    //     }\n    //     var res = new int[minHeap.Count];\n    //     int i=0;\n    //     while(minHeap.Count>0)\n    //     {\n    //         res[i]=minHeap.Dequeue().Item1;\n    //         i++;\n    //     }\n    //     return res;\n    // }\n}\n",
    "memory": 54420,
    "stdout": "",
    "language": "csharp",
    "time": "0.73",
    "problemId": "top-k-elements-in-list",
    "stderr": ""
}