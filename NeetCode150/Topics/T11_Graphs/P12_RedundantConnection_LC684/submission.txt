2, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    IRedundantConnectionFinder soln;\n    public int[] FindRedundantConnection(int[][] edges) {\n        //[WRONG] My first thoughts: Naieve solution would be doing a loop starting from the end of the array and for each edge we see if removing it removes the cycle (by doing a DFS from 0). \n        //Checked NeetCode's Naieve optimal DFS solution, and its very different from the above idea. //Note that the solution is not practically efficient since new int[n] used for `visited` is an O(n) operation since it sets all values to default value of the thing. But then again, we do another O(x) \n        \n        //Actually, the first edge that adds the cycle is the last edge that removes the cycle (because there were no cycles before it).  [That's why my idea was not good]\n        //Adding one edge to a tree will always create exactly one cycle. Thus, the redundant edge is the one that closes this cycle.\n        //Watched the neetcode video (except the implementation part) and now I know the best solution would Union Findl\n\n        //READ THE QUESTION PROPERLY LMAO!! I DIDN'T READ n == numVertices == edges.Length, I kinda ended up doing it without understanding/paying_attention anyway though. \n\n        //Union Find by Size using Disjoint Union Sets:\n        // !!! [~~IMPORTANT~~] HAD TO WATCH NeetCode's VIDEO TO SEE HOW TO SOLVE THIS PROBLEM because I thought UnionFind wouldn't work here but the union operator can also help find cycles like we do here !!!\n        soln = new UnionFind_BySize_WithPathCompression_1();\n\n        // [Note] Watch\n\n\n        return soln.FindRedundantConnection(edges);\n    }\n}\n\n\npublic interface IRedundantConnectionFinder\n{\n    int[] FindRedundantConnection(int[][] edges);\n}\n\n\npublic class UnionFind_BySize_WithPathCompression_1 : IRedundantConnectionFinder\n{\n    public int[] FindRedundantConnection(int[][] edges) \n    {\n        DisjointUnionSets dsu = new(edges.Length); //TC: O(V), SC:O(V)\n\n        foreach(var edge in edges) //O(E*ackerman(V))~=O(E)\n        {\n            if(!dsu.Union(edge[0], edge[1]))\n                return edge;\n        }\n\n        throw new Exception(\"No cycle found.\");\n    }\n\n    private class DisjointUnionSets\n    {\n        int[] parent;\n        int[] size; //number of children + 1(for itself)\n\n        public DisjointUnionSets(int numNodes)\n        {\n            //we use numNodes+1 so that we can have a 1-1 mapping from node to its size or parent. The 0th index is just an extra that's never used. (we even start the loops from 1)\n            parent = new int[numNodes+1];\n            size = new int[numNodes+1];\n            parent[0] = size[0] = int.MinValue; //Never used, so I could've kept them as is, but I just decided to keep it a negative number (int.MinValue) for no reason.\n            for(int i=1; i<numNodes+1; i++)\n            {\n                parent[i] = i;\n                size[i] = 1;\n            }\n        }\n\n        public bool Union(int u, int v) //Returns false if the members are already connected, which means the last node to induce a cycle will return false right away.\n        {\n            int rootToAttach = Find(u);\n            int rootTarget = Find(v);\n\n            if(rootToAttach == rootTarget)\n                return false; //Already in the connected set.\n\n            if(size[rootToAttach] > size[rootTarget])\n            {\n                int temp = rootTarget;\n                rootTarget = rootToAttach;\n                rootToAttach = temp;\n            }\n\n            parent[rootToAttach] = rootTarget;\n\n            return true;\n        }\n\n        public int Find(int child) //Due to the nature of Path Compression (and since find is also called in union), the maximum height/depth of any tree representing a set is 2 (as explained in my solution to `Number of Connected Components In An Undirected Graph`)\n        {\n            if(child != parent[child]) //Root's parent is itself.\n                parent[child] = Find(parent[child]); //Path compression/\n            return parent[child];\n        }\n\n    }\n}",
    "problemId": "redundant-connection",
    "statusDescription": "Accepted",
    "time": "0.418",
    "date": "2024-11-23T22:30:13.929Z",
    "memory": 54952,
    "stdout": "",
    "stderr": ""
}