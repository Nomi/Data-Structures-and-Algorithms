1, Wrong Answer
{
    "language": "csharp",
    "code": "public class Solution {\n    public int OrangesRotting(int[][] grid) {\n        return msbfs1(grid);\n    }\n\n    const int empty = 0;\n    const int fresh = 1;\n    const int rotten = 2;\n\n    //TC: O(r*c)\n    //SC: O(r*c) //worst case being when every cell is a rotten fruit.\n    public int msbfs1(int[][]grid)\n    {\n        //IMPOTTANT NOTES:\n        // - Coming up with the freshFruitCount was(or seems like) a happy accident.\n        // - I FORGOT TO READ THE QUESTION AGAIN AND DIDN'T REALIZE I NEEDED TO RETURN A -1\n        // - I NEED TO MAKE SURE TO NOT JUST ASSUME STUFF IN THE INTERVIEWS (WHERE THIS KIND OF STUFF ISN'T EVEN LISTED, BUT YOU'RE REQUIRED TO ASK OR STATE YOUR ASSUMPTIONS)\n\n        int maxSeconds = 0;\n        int freshFruitCount = 0;\n        Queue<(int r, int c)> q = new();\n\n        //Add the starting points (sources)\n        for(int r=0; r<grid.Length; r++) //TC: O(r*c)\n        {\n            for(int c=0; c<grid.Length; c++)\n            {\n                if(grid[r][c]==rotten)\n                    q.Enqueue((r,c));\n                else if(grid[r][c]==fresh)\n                    freshFruitCount++;\n            }\n        }\n\n        //BFS\n        while(q.Count>0) //TC: O(r*c)\n        {\n            (int r, int c) = q.Dequeue();\n            handleCurrent1(r-1, c, r, c, ref maxSeconds, ref freshFruitCount, grid, q);\n            handleCurrent1(r+1, c, r, c, ref maxSeconds, ref freshFruitCount, grid, q);\n            handleCurrent1(r, c-1, r, c, ref maxSeconds, ref freshFruitCount, grid, q);\n            handleCurrent1(r, c+1, r, c, ref maxSeconds, ref freshFruitCount, grid, q);\n        }\n        if(freshFruitCount!=0) //check handleCurrent1 comments.\n            return -1;\n        return maxSeconds-2; //-2 to remove the initial 2 we add from the rotten fruit start.\n    }\n    public void handleCurrent1(int r, int c, int prevR, int prevC, ref int maxSeconds, ref int freshFruitCount, int[][] grid, Queue<(int r, int c)> q)\n    {\n        if(r<0 || c<0 || r>=grid.Length || c>=grid.Length || grid[r][c]!=fresh)\n            return;\n        freshFruitCount--; //due to the condition, each fresh fruit will be processed only once and that too by its nearest rotten fruit (or whichever ends up in being first in the queue if there are multiple same distance away).\n        grid[r][c] += grid[prevR][prevC]; //think about it. it works out to place number of minutes required for the rot to reach current place.\n        if(grid[r][c]>maxSeconds) maxSeconds = grid[r][c];\n        q.Enqueue((r,c));\n    }\n}\n",
    "problemId": "rotting-fruit",
    "statusDescription": "Wrong Answer",
    "time": "0.426",
    "date": "2024-11-20T23:17:59.338Z",
    "memory": 58576,
    "stdout": "",
    "stderr": ""
}