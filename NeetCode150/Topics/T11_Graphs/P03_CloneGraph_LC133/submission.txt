1, Accepted
{
    "language": "csharp",
    "code": "/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public IList<Node> neighbors;\n\n    public Node() {\n        val = 0;\n        neighbors = new List<Node>();\n    }\n\n    public Node(int _val) {\n        val = _val;\n        neighbors = new List<Node>();\n    }\n\n    public Node(int _val, List<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\npublic class Solution {\n    public Node CloneGraph(Node node) {\n        //GO THROUGH MY bfs1 ATTEMPT (AND MAYBE WATCH NEETCODE VIDEO???)\n        //KINDA EASY BUUUT TRICKYYYY\n        return bfs1(node);\n    }\n\n    //TC: O(V+E)\n    //SC: O(V)\n    public Node bfs1(Node start)\n    {\n        if(start == null) return null; //I DID NOT EVEN THINK ABOUT IT!!! BE CAREFUL!!!!!!!\n        \n        var oldToNew = new Dictionary<Node, Node>();\n\n        var q = new Queue<Node>();\n        \n        oldToNew[start] = new Node(start.val); //So, before we even process an unseen node, as soon as we encounter it, we add its clone here.\n        q.Enqueue(start);\n\n        while(q.Count>0)\n        {\n            var curOld = q.Dequeue();\n            foreach(var nei in curOld.neighbors)\n            {\n                if(oldToNew.TryAdd(nei, new Node(nei.val))) //If it doesn't exist already, it means that it hasn't had its neighbors array filled yet. \n                {\n                   q.Enqueue(nei); //queue it up to fill neighbors\n                }\n                oldToNew[curOld].neighbors.Add(oldToNew[nei]); //fill curOld's current neighbor nei\n            }\n        }\n        return oldToNew[start];\n    }\n    // public Node bfs1(Node node) //I WAS TRYING TO DO IT IN SUCH A CONVOLUTED WAY!!\n    // {\n    //     if(node == null) return null; //I DID NOT EVEN THINK ABOUT IT!\n    //     HashSet<int> seen = new();\n\n    //     Node dummy = new(-1, new List<int>());\n    //     Node parent = dummy;\n        \n    //     Queue<Node> q = new();\n    //     q.Enqueue(node);\n    //     while(q.Count>0)\n    //     {\n    //         var curToClone = q.Dequeue();\n    //         var curNew = new Node(curToClone.val, new());\n    //         parent.neighbours.Add(curNew);\n\n    //     }\n    // }\n}\n",
    "problemId": "clone-graph",
    "statusDescription": "Accepted",
    "time": "0.451",
    "date": "2024-11-20T00:35:40.474Z",
    "memory": 55504,
    "stdout": "",
    "stderr": ""
}