2, Accepted
{
    "language": "csharp",
    "code": "public class Solution \n{\n    ICourseSchedule soln;\n    public bool CanFinish(int numCourses, int[][] prerequisites) \n    {\n        //[!!!IMPORTANT!!!] \n        //NEED TO PRACTICE!!! \n        //I had done this approximately 3 months ago but forgot.\n        //I started by trying an overcomplicated method (using Nodes and building adjacency lists, etc.),\n        //but when it got too complicated I checked the solution on neetcodeio and remembered we could do it the way I finally ended up doing it in DfsAttempt1.\n        //I think I have heard of Kahn's algorithm but forgot.\n        \n        //[!!!IMPORTANT!!!] \n        //CHECK THE [OPTIMIZATION] comment IN DfsAttempt1.dfsCycleDetector\n        //I DID NOT REALIZE UNTIL THE END WHEN I WAS CALCULATING TIMECOMPLEXITY THAT WE COULD OPTIMIZE THIS WAY!!!\n        //I did refer(sneak a peak at) to neetcodeio soln how they did it for inspiration.\n        \n        soln = new DfsAttempt1();\n        return soln.CanFinish(numCourses, prerequisites);\n    }\n}\n\npublic interface ICourseSchedule\n{\n    bool CanFinish(int numCourses, int[][] prerequisites);\n}\n\npublic class DfsAttempt1 : ICourseSchedule\n{\n    Dictionary<int, List<int>> prereqMap;\n    HashSet<int> visiting;\n\n    public bool CanFinish(int numCourses, int[][] prerequisites) \n    {\n        prereqMap = new(numCourses);\n        visiting = new();\n        \n        //Fill prereqMap:\n        for(int i=0; i<prerequisites.Length;  i++) //O(N) where N is numCourses\n        {\n            prereqMap.TryAdd(prerequisites[i][0], new());\n            prereqMap[prerequisites[i][0]].Add(prerequisites[i][1]);\n            // prereqMap.TryAdd(prerequisites[i][1], new()); //Uncomment this if you either: 1. don't initialize hashmap for every course already in a loop above this one 2. in dfs, return true if prereqMap does not contain the course as a Key (because otherwise the program breaks/throws_exception because of the key not being present)\n        }\n\n        //DFS to find cycles (meaning you can't take courses in that cycle):\n        //O(N*())\n        for(int course=0; course<numCourses; course++) //Given that that the courses will be numbered 0 to numCourses-1, we can manually use a normal for loop to do that instead of looping over prereqMap keys.\n        {\n            if(false == dfsCycleDetector(course)) //CHECK THE [OPTIMIZATION] comment IN dfsCycleDetector\n                return false;\n        }\n\n        return true;\n    }\n\n    bool dfsCycleDetector(int course)\n    {\n        if(visiting.Contains(course))\n            return false;\n\n        if(false == prereqMap.ContainsKey(course)) //Has no prerequisites.\n            return true;\n        \n        visiting.Add(course);\n\n        foreach(var prereq in prereqMap[course])\n        {\n            if( false == dfsCycleDetector(prereq))\n                return false;\n        }\n        \n        visiting.Remove(course);\n        prereqMap.Remove(course); //[OPTIMIZATION] DAMN! I WAS CALCULATING TIME COMPLEXITY AND ONLY THEN DID I REALIZE OF THIS IMPROVEMENT!!! (since we already found it doesn't need prerequisites), this way we will never go through it again, saving us time.\n        return true;\n    }\n}\n// public class DEPRECATED_DfsAttempt1 : ICourseSchedule //I WAS OVERCOMPLICATING IT BECAUSE I DIDN'T EVEN NEED A NODE CLASS!! CHECK THE NEW `DfsAtt1emp1`!!!\n// {\n//     const UNVISITED = 1;\n//     const VISITING = 1;\n//     const VISITED = 2;\n//     internal class Node\n//     {\n//         public int course;\n//         public int state;\n//         public List<int> prereqs;\n//         public Node(int _course)\n//         {\n//             course = _course;\n//             dependancyOf = new();\n//             state = UNVISITED;\n//         } \n//     }\n//     public bool CanFinish(int numCourses, int[][] prerequisites)\n//     {\n//         //1. Make an adjacency list\n//         Dictionary<int, Node> adjList = new(n);\n//         for(int r = 0; r<prerequisites.Length; r++) //O(numCourses^2)\n//         {\n//             //READ THE QUESTION PROPERLY!!! I WAS DOING IT THE OTHER WAY AROUND!!!\n//             adjList.TryAdd(prerequisites[r][0], new(prerequisites[r][0]));\n//             adjList.TryAdd(prerequisites[r][1], new(prerequisites[r][1]));\n//             adjlist[prerequisites[r][0]].dependancyOf.Add(prerequisites[r][1]);\n//         }\n\n//         //2. DFS to find any cycles\n//         foreach((int key, Node node) in adjList)\n//         {\n//             if(node.state != VISITED)\n\n//         }\n//     }\n\n//     bool dfs(node)\n//     {\n//         if(node==VISITING) //CYCLE\n//             return false;\n//         foreach(int )\n//     }\n// }",
    "problemId": "course-schedule",
    "statusDescription": "Accepted",
    "time": "0.488",
    "date": "2024-11-21T23:29:45.824Z",
    "memory": 56036,
    "stdout": "",
    "stderr": ""
}