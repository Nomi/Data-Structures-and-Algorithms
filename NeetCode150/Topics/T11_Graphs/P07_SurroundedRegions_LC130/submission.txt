7, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n\n    ISurroundedRegionsSolver solver;\n    public void Solve(char[][] board) {\n        // # IMPORTANT NOTES:\n        // * COULDN'T COME UP WITH THE SOLUTION ON MY OWN (did think about trying to invert the problem but I did not invert it correctly enough)\n        // * HAD TO WATCH NEETCODE'S VIDEO TO WRITE THIS!!!!\n        // * READ THE COMMENTS FOR Dfs1\n        solver = new Dfs1();\n        solver.Solve(board);\n    }\n}\n\npublic interface ISurroundedRegionsSolver\n{\n    void Solve(char[][] board);\n}\n\npublic class Dfs1 : ISurroundedRegionsSolver\n{\n    // * COULDN'T COME UP WITH THE SOLUTION ON MY OWN (did think about trying to invert the problem but I did not invert it correctly enough)\n    // * HAD TO WATCH NEETCODE'S VIDEO TO WRITE THIS!!!!\n\n    const char O = 'O';\n    const char X = 'X';\n    const char NOT_SURROUNDED = '#';\n    // int ROWS;\n    // int COLS;\n    public void Solve(char[][] board) \n    {\n        // ROWS = board.Length;\n        // COLS = board[0].Length;\n\n        //Clearly, for an edge to be NOT SURROUNDED, it needs to connect directly OR indirectly to the outer boundaries of the array.\n        // [!!!IMPORTANT!!!] DOING IT ALL TOGETHER IN ONE LOOP BREAKS IT!!! //[ANSWER] TURNS OUT \n\n        //1. MARK SURROUNDED TILES\n\n        //If NUM ROWS == NUM COLS\n        // for(int rc=0; rc<board.Length; rc++) //Assumes NUM ROWS == NUM COLS ////technically we can ignore the top left, top right, bottom left, and bottom right cells because they can't encase or un-encase anything.\n        // {\n        //     if(board[rc][0] == O) markNotSurroundedIfVistedDfs(rc, 0, board);//LEFT EDGE\n        //     markNotSurroundedIfVistedDfs(0, rc, board);//TOP EDGE\n        //     markNotSurroundedIfVistedDfs(rc, board.Length-1, board);//RIGHT EDGE\n        //     markNotSurroundedIfVistedDfs(board[0].Length-1, rc, board);//BOTTOM EDGE\n        // }\n        \n        //If NUM ROWS != NUM COLS\n        for(int r=0; r<board.Length; r++) //technically we can ignore the top left, top right, bottom left, and bottom right cells because they can't encase or un-encase anything.\n        {\n            if(board[r][0] == O) markNotSurroundedIfVistedDfs(r, 0, board);//LEFT EDGE\n            if(board[r][board[0].Length-1] == O) markNotSurroundedIfVistedDfs(r, board[0].Length-1, board);//RIGHT EDGE\n        }\n        for(int c=0; c<board[0].Length; c++)\n        {\n            if(board[0][c] == O) markNotSurroundedIfVistedDfs(0, c, board);//TOP EDGE\n            if(board[board.Length-1][c] == O) markNotSurroundedIfVistedDfs(board.Length-1, c, board);//BOTTOM EDGE      //I SPENT HOURS DEBUGGING THIS WHOLE PROGRAM WITH NO IDEA WHAT WAS WRONG BUT I WAS USING [0] IN THE INDEDX INSTEAD OF [c]!!\n        }\n\n\n        //2. TURN NOT_SURROUNDED TILES BACK TO `O`s AND SURROUNDED TO `X`s.\n        for(int r=0; r<board.Length; r++)\n        {\n            for(int c=0; c<board[0].Length; c++) //assumes every row is of same length\n            {\n                if(board[r][c] == O)\n                    board[r][c] = X;\n                else if(board[r][c] == NOT_SURROUNDED)\n                    board[r][c] = O;\n            }\n        }\n    }\n\n    public void markNotSurroundedIfVistedDfs(int r, int c, char[][] board)\n    {\n        // Console.WriteLine($\"{r}!={board.Length},{c}!={board[0].Length}\");\n        if( r<0 || c<0 || r == board.Length || c == board[0].Length || board[r][c] != O ) //Additional note: anything already visited would have visited its neighbors too, so no need to repeat (also if we allowed NOT_VISITED there will be cycles.)\n            return;\n        // Console.WriteLine($\">> TRUE\");\n\n        board[r][c] = NOT_SURROUNDED;\n\n        markNotSurroundedIfVistedDfs(r-1, c, board);//up\n        markNotSurroundedIfVistedDfs(r+1, c, board);//down\n        markNotSurroundedIfVistedDfs(r, c-1, board);//left\n        markNotSurroundedIfVistedDfs(r, c+1, board);//right\n    }\n}\n",
    "problemId": "surrounded-regions",
    "statusDescription": "Accepted",
    "time": "0.428",
    "date": "2024-11-21T22:11:40.967Z",
    "memory": 55352,
    "stdout": "",
    "stderr": ""
}