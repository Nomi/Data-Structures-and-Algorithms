1, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    public int CountComponents(int n, int[][] edges) {\n        return Dfs1Wrapper(n, edges);\n    }\n\n    int Dfs1Wrapper(int n, int[][] edges)\n    {\n        //1. Make adjacency list:\n        List<List<int>> nodeEdges = new(n);\n        for(int i=0; i<n; i++)\n        {\n            nodeEdges.Add(new());\n        }\n\n        foreach(var edge in edges)\n        {\n            nodeEdges[edge[0]].Add(edge[1]);\n            nodeEdges[edge[1]].Add(edge[0]);\n        }\n\n        //2. Graph traversal to mark connected components:\n\n        int numConnectedComponents = 0;\n        HashSet<int> visited = new(n); //To track nodes already visited (helps with cycle detection and also checking if a node is a part of a connected component discovered before)\n\n        for(int node = 0; node<n; node++)\n        {\n            if(visited.Contains(node))\n                continue;\n            numConnectedComponents++;\n            dfsMarkThisAndConnectedNodesAsVisited(node, -1, visited, nodeEdges); //assuming we can use -1 as a dummy parent node for first level of recursion.\n        }\n        return numConnectedComponents;\n    }\n\n    void dfsMarkThisAndConnectedNodesAsVisited(int curNode, int parentNode, HashSet<int> visited, List<List<int>> nodeEdges) //O(V+E) because we go through each node at most once and the total sum of all paths from one node to another (edges) will sum up to E because 1 edge only occurs between 1 pair of vertices. (I think I phrased it shitty, but give me a break. I have a headache.)\n    {\n        if(visited.Contains(curNode))\n            return; //We don't need to process this branch anymore as it is a cycle (it can't be something we visited for a different connected component exactly because then that and this connected component would be connected and would actually be only one connected component, but that's not true)\n        visited.Add(curNode);\n        foreach(int childNode in nodeEdges[curNode])\n        {\n            if(childNode == parentNode) //Since we came from there, we don't need to process it again. In fact that would lead to a false-positive detection of a cycle.\n                continue;\n            dfsMarkThisAndConnectedNodesAsVisited(childNode, curNode, visited, nodeEdges);\n        }\n    }\n}\n",
    "problemId": "count-connected-components",
    "statusDescription": "Accepted",
    "time": "0.431",
    "date": "2024-11-22T21:58:23.574Z",
    "memory": 55892,
    "stdout": "",
    "stderr": ""
}