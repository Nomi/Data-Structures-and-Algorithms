11, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    public int CountComponents(int n, int[][] edges) {\n        IComponentsCounter soln;\n\n        //Did it by myself since I had done a similar problem Graph Valid Tree an hour or two ago. (though that one took me a long while, this one was done in ~20 minutes)\n        //Refer to Graph Valid Tree if needed.\n        \n        soln = new Dfs1();\n\n        // DFS is actually perfectly fine for this, but if you wanted to, \n        // for Union Find using Disjoin Union Set, watch Union Find in 5 minutes by Potato Coders on YouTube\n        // According to a comment on the video: He does forget to mention that you have to union the shorter tree into the longer tree, otherwise the trees is in a set of n elements can be up to n elements long (just a straight chain, instead of branching) and you don't get log(n) complexity.\n        // To get O(log2(n)) complexity, you need to use union by rank or size.\n        // There's also Path Compression to further optimize if we don't need direct parents\n        // ALSO, MUST WATCH if you want to do Union Find: William Fisset's videos on Union Find `Union Find - Union and Find Operations` and `Union Find Path Compression`\n        // ULTRA MUST WATCH: TakeUForward's VIDEO ON UnionFind (G-46)\n        // Also, watch Neetcode's video on this problem to see how it applies here. I plan to watch it before solving.\n        \n        //soln = new UnionFind_DisjointUnionSet_UnionBySize_WithPathCompression_1();\n\n\n        return soln.CountComponents(n, edges);\n    }\n}\n\n\npublic interface IComponentsCounter\n{\n    int CountComponents(int n, int[][] edges);\n}\n\npublic class Dfs1 : IComponentsCounter\n{\n    public int CountComponents(int n, int[][] edges)\n    {\n        //1. Make adjacency list:\n        List<List<int>> nodeEdges = new(n); //SC: O(V+E) [V==n]  because there are V List<ints>, and the sum of all the nodes in those lists is E (because the lists contain the vertex on the other end of the edges from the V indices)\n        for(int i=0; i<n; i++) //O(n)==O(V)\n        {\n            nodeEdges.Add(new());\n        }\n\n        foreach(var edge in edges)\n        {\n            nodeEdges[edge[0]].Add(edge[1]);\n            nodeEdges[edge[1]].Add(edge[0]);\n        }\n\n        //2. Graph traversal to mark connected components:\n\n        int numConnectedComponents = 0;\n        HashSet<int> visited = new(n); //To track nodes already visited (helps with cycle detection and also checking if a node is a part of a connected component discovered before)\n\n        for(int node = 0; node<n; node++) //TC (including DFS): O(V+E) where V==n, because we only visit each node once and the number of other nodes we visit from each node sums up to the total number of edges because we only traverse each edge only once using the hashset's power (obvious / by definition).\n        {\n            if(visited.Contains(node))\n                continue;\n            numConnectedComponents++;\n            dfsMarkThisAndConnectedNodesAsVisited(node, -1, visited, nodeEdges); //assuming we can use -1 as a dummy parent node for first level of recursion.\n        }\n        return numConnectedComponents;\n    }\n\n    void dfsMarkThisAndConnectedNodesAsVisited(int curNode, int parentNode, HashSet<int> visited, List<List<int>> nodeEdges) //O(V+E) because we go through each node at most once and the total sum of all paths from one node to another (edges) will sum up to E because 1 edge only occurs between 1 pair of vertices. (I think I phrased it shitty, but give me a break. I have a headache.)\n    {\n        if(visited.Contains(curNode))\n            return; //We don't need to process this branch anymore as it is a cycle (it can't be something we visited for a different connected component exactly because then that and this connected component would be connected and would actually be only one connected component, but that's not true)\n        visited.Add(curNode);\n        foreach(int childNode in nodeEdges[curNode])\n        {\n            if(childNode == parentNode) //Since we came from there, we don't need to process it again. In fact that would lead to a false-positive detection of a cycle.\n                continue;\n            dfsMarkThisAndConnectedNodesAsVisited(childNode, curNode, visited, nodeEdges);\n        }\n    }\n}\n\npublic class UnionFind_DisjointUnionSet_UnionBySize_WithPathCompression_1 : IComponentsCounter\n{\n    //Very useful when the graph is changing (e.g. executing Find somewhere in between of Union calls)\n    //TakeUForward helped a lot! And for some of how to code it (especially doing the find function iteratively instead of recursively, though now that I think about it, it wouldn't really affect the performance much in this case), I took a look at the soln on NeetCodeIo even though it is by rank.\n    public int CountComponents(int n, int[][] edges) //TC: O(V + E*\u03b1(n)) where \u03b1(n) is the inverse Ackerman function, which is less than 5 for any practical input size n. //See also: https://tarunjain07.medium.com/union-find-disjoint-set-union-dsu-notes-24f3e228858d#30a0 AND https://stackoverflow.com/questions/6342967/why-is-the-ackermann-function-related-to-the-amortized-complexity-of-union-find\n    {\n        DSU dsu = new(n); //TC: O(V)\n        \n        int numRoots = n; //at the start of DSU, everything is a root.\n\n        foreach(var edge in edges) //O(E*\u03b1(V)) where \u03b1 is <= 5 for any 'reasonable' input\n        {\n            if(dsu.Union(edge[0], edge[1]))\n                numRoots--;\n        }\n        return numRoots;\n        // I DIDN'T THINK OF THE ABOVE SOLUTION! WAS GOING TO DO THE FOLLOWING CONVOLUTED SOLUTION UNTIL I SAW THIS PART OF NEETCODEIO SOLN!!\n        //WELL, technically I did think of keeping count like the above approach, but in the DSU class itself and being the idiot I am, I decided against it somehow. \n\n        // HashSet<int> connectedComponentRoots = new();\n\n        // for(int i=0; i<n; i++ )//~=O(V) where \u03b1 is <= 5 for any 'reasonable' input)\n        // {\n                //I had planned to do find here lol\n        // }\n\n        // for(int )\n    }\n    private class DSU\n    {\n        //SC: O(V)\n        int[] nodeToParent;\n        int[] numChildren; //Usually called `Size` in DSU\n\n        public DSU(int numNodes)//TC: O(V) (in fact, it is amortized(exactly) v, so \u03b1(v))\n        {\n            numChildren = new int[numNodes]; //C# initializes them all to 0 and that's the value we want because all nodes are ROOT nodes (no parents) with no children before edges are added\n            nodeToParent = new int[numNodes];\n            for(int node=0; node<numNodes; node++)//TC: O(V) //The parent of each ROOT node is the node itself, and at the beginning everything is a root (no parents) since no union has been called\n            {\n                nodeToParent[node] = node;\n            }\n        }\n\n        //TC: \u03b1(V)\n        public bool Union(int u, int v) //returns false if already in same component, otherwise returns true after uniting them\n        {\n            int uRoot = Find(u); //usually labeled `pu` in DSU\n            int vRoot = Find(v); //usually labeled `pv` in DSU\n            if( uRoot == vRoot )\n                return false; //already the same set/connected_component/Union\n            \n            int parent = uRoot, child = vRoot; //I WAS USING u and v HERE EARLIER AND THAT'S WRONG!! (and breaks tings!!)\n            if(numChildren[vRoot]>numChildren[uRoot])\n            {\n                parent = vRoot;\n                child = uRoot;\n            }\n            nodeToParent[child] = parent;\n            numChildren[parent] += 1+numChildren[child];\n\n            return true;\n        }\n\n        //TC: ~O(1)\n        public int Find(int curNode) //returns the root node, which acts as the representative for its current set/connected_component\n        {\n            //Notice that due to path compression, we will NEVER have a tree with depth bigger than 3 (because all nodes are attached to root making length 2, and if we union that with another node which has bigger `size` (numChildren), then the resulting graph/tree will have depth 3)\n            //Due to the above comment, I could've done it via recursion and it would be fine performance wise and from any other aspect. In fact, it would be easier to come up with the iterative approach (had to check neetcodeio soln to see how to do it, even though they were doing by rank, some parts (including this) remained same or similar)\n            while(curNode != nodeToParent[curNode]) //Parent of a node being itself means it is a root\n            {\n                nodeToParent[curNode] = nodeToParent[nodeToParent[curNode]]; //This doesn't break because the parent of the root is the root itself. //Also, works due to the depth being <= 3.\n                curNode = nodeToParent[curNode];\n            }\n\n            return curNode; //due to while loop condition, it is the root.\n        }\n    }\n}",
    "problemId": "count-connected-components",
    "statusDescription": "Accepted",
    "time": "0.399",
    "date": "2024-11-23T02:01:24.384Z",
    "memory": 57280,
    "stdout": "",
    "stderr": ""
}