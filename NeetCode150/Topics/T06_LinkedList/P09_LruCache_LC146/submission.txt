3, Compilation Error
{
    "date": "2024-09-28T01:47:50.975Z",
    "statusDescription": "Compilation Error",
    "code": "public class LRUCache {\n    //Read my solution Attempt1 as it is uses some nifty and useful tricks!!!!\n    Attempt1 attempt1;\n    public LRUCache(int capacity) {\n        attempt1 = new(capacity);\n    }\n    \n    public int Get(int key) {\n        attempt1.Get(key);\n    }\n    \n    public void Put(int key, int value) {\n        attempt1.Put(key, value);\n    }\n}\n\n\npublic class Attempt1\n{\n    public class Node \n    {\n        public Node prev;\n        public Node next;\n        \n        //key is important for removal from dictionary.\n        public int key;\n        public int val;\n        public Node(int _key, int _val)\n        {\n            key = _key;\n            val = _val;\n            prev = null;\n            next = null;\n        }\n    }\n    Dictionary<int, Node> cache;\n    int cap;\n    Node left;\n    Node right;\n\n    public void RemoveNode(Node node)\n    {\n        var nodePrev = node.prev;\n        var nodeNext = node.next;\n        nodePrev.next = nodeNext;\n        nodeNext.prev = nodePrev;\n    }\n    public void InsertNodeAtEnd(Node node)\n    {\n        var rightPrev = right.prev;\n        rightPrev.next = node;\n        node.prev = right.prev;\n        node.next = right;\n        right.prev = node;\n    }\n\n\n    public Attempt1(int capacity) {\n        cap = capacity;\n        cache = new(cap);\n        left = new(-1,-1);\n        right = new(-1,-1);\n        left.next = right;\n        right.prev = left;\n    }\n    \n    public int Get(int key) {\n        if(cache.TryGetValue(key, out var node))\n        {\n            RemoveNode(node);\n            InsertNodeAtEnd(node);\n            return node.val;\n        }\n        return -1;\n    }\n    \n    public void Put(int key, int value) \n    {\n        if(cache.TryGetValue(key, out var existingNode))\n        {\n            RemoveNode(existingNode);\n            InsertNodeAtEnd(existingNode);\n            existingNode.val = value;\n            return;\n        }\n        if(cache.Count==cap)\n        {\n            //Order matters:\n            cache.Remove(left.next.key);\n            RemoveNode(left.next);\n        }\n        Node node = new(key, value);\n        InsertNodeAtEnd(node);\n        cache.Add(key, node);\n    }\n}",
    "memory": "",
    "stdout": "",
    "language": "csharp",
    "time": "0.0",
    "problemId": "lru-cache",
    "stderr": ""
}