1, Accepted
{
    "date": "2024-09-25T21:38:13.983Z",
    "statusDescription": "Accepted",
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\n        return attempt1(head, n);\n    }\n\n\n\n    public ListNode attempt1(ListNode head, int n)\n    {\n\n        //[ ! ! ! IMPORTANT ! ! ! ] \n        // ENABLES HANDLING OF THE EDGE CASE\n        // WHERE WE DELETE THE HEAD ITSELF!\n        ListNode dummy = new ListNode(-1, head); //Dummy node to store the result  \n        \n        //First, let's get a pointer to the (n+1)th element FROM THE FRONT\n        var nPlus1ThElemFromFront = head;\n        int pos = 1;\n        while(pos<=n)\n        {\n            nPlus1ThElemFromFront = nPlus1ThElemFromFront.next;\n            pos++;\n        }\n        \n        //Now, notice that the difference in position (distance) between head (1st element) and the (n+1)th element is n. So, let\n        ListNode l = dummy, r = nPlus1ThElemFromFront; //NOTICE THAT l=dummy HELPS US WITH THE CASE WHERE WE'RE DELETING THE HEAD.\n        //From earlier comment, we can see that the distance between the l.next and r is n.\n        //Therefore, we can see that if we keep incrementing l and r together at the same time,\n        //when r is at the last element, l.next will be n+1 elements before that.\n        //Which also means, that when you include the last element, \n        //l.next is the n+1-th element from the end of the list (null).\n\n        //To make it handle the new l = dummy based approach for the edge case where we're deleting the head,\n        // we should just check r!=null, because when r=null (the end of the list), the distance of\n        // l.next from the end of the list is n and the distance of l from the end of the list is n+1.\n        // Which is what we need. \n        while(r!=null)\n        {\n            l=l.next;\n            r=r.next;\n        }\n        // Console.WriteLine(l?.val);\n        // Console.WriteLine(r?.val);\n        // Console.WriteLine(l?.next?.val);\n        // Console.WriteLine(l?.next?.next?.val);\n\n        //as discussed above, l is the n+1-th element fromt he end of the list.\n        var lNextNext = l?.next?.next;//this is the n-1-th element from the end of the list.\n        l.next = lNextNext; //this removes the reference to the n-th node from the end and as such the garbage collector will eventually clean it up.\n        \n        return dummy.next;\n    }\n}\n",
    "memory": 54372,
    "stdout": "",
    "language": "csharp",
    "time": "0.805",
    "problemId": "remove-node-from-end-of-linked-list",
    "stderr": ""
}