1, Accepted
{
    "date": "2024-09-30T21:09:44.696Z",
    "statusDescription": "Accepted",
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode ReverseKGroup(ListNode head, int k) {\n        // Console.WriteLine(attempt1.tupleTest().a);\n\n        //WATCHED NEETCODE VIDEO WHILE DOING THIS!!\n        //SO, USE THAT FOR REFERENCE!!! (Easy but remember the merge sort trick, and how it could apply to problems(like this one))\n        //I ALSO HAVE A FEELING THAT DUE TO USING THE NEETCODE SOLUTION WHILE WRITING THIS, I MIGHT NOT BE ABLE TO SOLVE THIS OR A SIMILAR PROBLEM BY MYSELF IN AN INTERVIEW SETTING??\n        return attempt1.ReverseKGroup(head, k);\n    }\n}\n\n//WATCHED NEETCODE VIDEO WHILE DOING THIS!!\npublic static class attempt1\n{\n    public static (int a, int b) tupleTest()\n    {//THESE ALL WORK!!!\n        //Honestly, tested for no reason. (they still work tho!!)\n        //Case 1:\n        return (0,1);\n        //Case 2:\n        // return (a: 0,b: 1);\n    }\n    public static ListNode ReverseKGroup(ListNode head, int k) \n    {\n        ListNode dummy = new(-1);\n        dummy.next = head;\n        ListNode prevGrpTail = dummy;\n\n        //GENERAL TRICK: REMEMBER TO USE WHILE(TRUE) IN YOUR SOLUTIONS UNTIL YOU FIND THE BREAK CONDITION [If it exists and you don't know it already, or just use while(true) if that's more convenient].\n        while(true)\n        {\n            var curTail = getKPlus1thFromNow(prevGrpTail, k);\n            if(curTail==null)\n                break; //not enough elements for a group of k elements, end of list.\n            var nextGrpHead = curTail.next;\n\n            var cur = prevGrpTail.next;\n            var prev = nextGrpHead;\n            while(cur != nextGrpHead) //IDK why, but this condition, even though extremely easy to come up with, didn't come to me immediately so I just checked the NC .io solution\n            {\n                var curNext = cur.next;\n                cur.next = prev;\n                prev = cur;\n                cur = curNext;\n            }\n\n            //THE ABOVE DOESN'T CHANGE THE NEXT POINTER OF THE TAIL OF THE PREVIOUS GROUP!!!\n            //SO WE HANDLE THAT HERE:\n            var prevCurHeadNowCurTail = prevGrpTail.next;\n            prevGrpTail.next = curTail; //curTail is now curHead (because of above reversing loop)\n            prevGrpTail = prevCurHeadNowCurTail;\n        }\n\n        return dummy.next;\n    }\n    // public static void reverseK(ListNode lastElemOfPrevList, int k)\n    // {\n    //     var head = lastElemOfPrevList.next;\n    //     var tail = getKth(curr, k);\n    //     lastElemOf\n    // }\n    public static ListNode getKPlus1thFromNow(ListNode curr, int k)\n    {\n        while(curr != null && k>0)\n        {\n            curr = curr.next;\n            k--;\n        }\n        return curr;\n    }\n}\n",
    "memory": 53676,
    "stdout": "",
    "language": "csharp",
    "time": "0.762",
    "problemId": "reverse-nodes-in-k-group",
    "stderr": ""
}