2, Accepted
{
    "date": "2024-09-26T00:23:22.327Z",
    "statusDescription": "Accepted",
    "code": "/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public Node next;\n    public Node random;\n    \n    public Node(int _val) {\n        val = _val;\n        next = null;\n        random = null;\n    }\n}\n*/\n\npublic class Solution {\n    public Node copyRandomList(Node head) {\n\n        //USE NEETCODE IO SOLUTION AS REFERENCE? \n        //Because, even though my solution (attempt1) and that are both using the same logic,\n        //that code is a little cleaner and less verbose (due to the structure).\n        \n        // return attempt1(head);\n        return NeetCodeIoSoln(head);\n    }\n    \n     public Node NeetCodeIoSoln(Node head) \n     {\n        Dictionary<Node, Node> oldToCopy = new Dictionary<Node, Node>();\n\n        Node cur = head;\n        while (cur != null) {\n            Node copy = new Node(cur.val);\n            oldToCopy[cur] = copy;\n            cur = cur.next;\n        }\n\n        cur = head;\n        while (cur != null) {\n            Node copy = oldToCopy[cur];\n            copy.next = cur.next != null ? oldToCopy[cur.next] : null;\n            copy.random = cur.random != null ? oldToCopy[cur.random] : null;\n            cur = cur.next;\n        }\n\n        return head != null ? oldToCopy[head] : null;\n    }\n\n    public Node attempt1(Node head)\n    {\n        Dictionary<Node, Node> orig2new = new();\n        Node dummy = new(-1);\n        Node newNode = dummy;\n        while(head!=null)\n        {\n            if(orig2new.ContainsKey(head))\n            {\n                newNode.next=orig2new[head];\n            }\n            else\n            {\n                newNode.next = new(head.val);\n                orig2new.Add(head, newNode.next);\n            }\n\n            newNode = newNode.next;\n            \n            if(head.random!=null)\n            {\n                if(orig2new.ContainsKey(head.random))\n                {\n                    newNode.random = orig2new[head.random];\n                }\n                else\n                {\n                    newNode.random = new(head.random.val);\n                    orig2new.Add(head.random, newNode.random);\n                }\n            }\n            \n            Console.WriteLine(head.val);\n\n            head = head.next;\n        }\n\n        return dummy.next;\n    }\n}\n",
    "memory": 53084,
    "stdout": "",
    "language": "csharp",
    "time": "0.855",
    "problemId": "copy-linked-list-with-random-pointer",
    "stderr": ""
}