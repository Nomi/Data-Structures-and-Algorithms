4, Accepted
{
    "language": "csharp",
    "code": "public class Solution {\n    public List<string> FindWords(char[][] board, string[] words) {\n        //Wasn't extremely hard, but very verbose (and the duplicates of words not being allowed was tricky).\n\n        //IMPORTANT!!! I DID NOT THINK ABOUT THE SAME WORD APPEARING MULTIPLE TIMES!! (good clarification question?)\n\n        return Attempt1.FindWords(board, words);\n    }\n}\n\n\npublic static class Attempt1\n{\n    private class TrieNode\n    {\n        public Dictionary<char, TrieNode> children = new(26);\n        public bool isWord = false;\n    }\n\n\tstatic char visited = '*';\n\tstatic TrieNode root;\n    static int maxWordLen;\n\t\n    public static List<string> FindWords(char[][] board, string[] words) {\n        root = new TrieNode();\n        maxWordLen = 0;\n        \n        foreach(var word in words)\n        {\n            AddWord(word, root);\n        }\n\n        HashSet<string> res = new(); //IMPORTANT!!! I DID NOT THINK ABOUT THE SAME WORD APPEARING MULTIPLE TIMES!! (good clarification question?)\n        List<char> wordSoFar = new(maxWordLen);\n\n        for(int r=0; r<board.Length;r++)\n        {\n            for(int c=0; c<board[0].Length;c++)\n            {\n                dfs(board, r, c, root, wordSoFar, res);\n            }\n        }\n\n        return res.ToList();\n    }\n\n    private static void dfs(char[][] board, int r, int c, TrieNode prevNode, List<char> wordSoFar, HashSet<string> res)\n    {\n        // Console.WriteLine($\"r:{r} / {board.Length-1}, c:{c} / {board[0].Length-1}\");\n        if(r<0||r>=board.Length||c<0||c>=board[0].Length||board[r][c]==visited||wordSoFar.Count==maxWordLen) //im dumb cuz I spend so long debugging just to realize I was using r > length and c > length instead of >= !!!\n        {\n            // Console.WriteLine($\"{r<0}||{r>=board.Length}||{c<0}||{c>=board[0].Length}\");\n            return;\n        }\n        // Console.WriteLine($\"--> {board[r][c]}, {wordSoFar.Count} / {maxWordLen}\");\n\n        if(!prevNode.children.ContainsKey(board[r][c]))\n            return;\n\n        var curChar = board[r][c];\n        board[r][c] = visited;\n        wordSoFar.Add(curChar);\n\n        var curNode = prevNode.children[curChar];\n        // if(curNode.isWord) Console.WriteLine($\"-----------------------------{string.Concat(wordSoFar)}\");\n        if(curNode.isWord) res.Add(string.Concat(wordSoFar));\n\n        dfs(board, r-1, c, curNode, wordSoFar, res);    //I SPENT SOOO FUCKING LONG TO DEBUG THE IF CONDITIONS AT THE TOP THAT I DIDN'T REALIZE THE PROBLEM WAS I WAS PASSING ROOT INSTEAD OF CURRENT NODE BY MISTAKE WTFFF!!!\n        dfs(board, r+1, c, curNode, wordSoFar, res);\n        dfs(board, r, c-1, curNode, wordSoFar, res);\n        dfs(board, r, c+1, curNode, wordSoFar, res);\n\n        wordSoFar.RemoveAt(wordSoFar.Count-1);\n        board[r][c] = curChar;\n    }\n\n\n    private static void AddWord(string word, TrieNode root)\n    {\n        if(maxWordLen < word.Length) maxWordLen = word.Length;\n\n        var parent = root;\n\n        foreach(char c in word)\n        {\n            parent.children.TryAdd(c, new TrieNode());\n            parent = parent.children[c];\n        }\n\n        parent.isWord = true;\n    }\n}\n",
    "problemId": "search-for-word-ii",
    "statusDescription": "Accepted",
    "time": "0.422",
    "date": "2024-11-19T02:07:09.958Z",
    "memory": 56948,
    "stdout": "",
    "stderr": ""
}