2, Accepted
{
    "language": "csharp",
    "code": "public class WordDictionary {\n    IWordDictionary soln;\n\n    public WordDictionary() {\n        //TBH it wasn't really hard. \n        //I knew we would have to use DFS but I just wanted to see if we would go for the \n        //more complicated approach (iterative until reaching wildcard), which would be \n        //better performing. Ended up with the simpler decision of just only using dfs.\n        soln =  new Attempt1();    \n    }\n    \n    public void AddWord(string word) {\n        soln.AddWord(word);\n    }\n    \n    public bool Search(string word) {\n        return soln.Search(word);\n    }\n}\n\n\npublic interface IWordDictionary\n{\n    public void AddWord(string word);\n    \n    public bool Search(string word);\n}\n\n\npublic class Attempt1 : IWordDictionary\n{\n    private class TrieNode \n    {\n        public bool canBeEndOfWord = false;\n        public Dictionary<char, TrieNode> children = new(26);\n    }\n\n    TrieNode root;\n    char wildcard = '.';\n\n    public Attempt1()\n    {\n        root = new();\n    }\n\n    public void AddWord(string word)\n    {\n        var cur = root;\n        \n        foreach(char c in word)\n        {\n            cur.children.TryAdd(c, new TrieNode());\n\n            cur = cur.children[c];\n        }\n\n        cur.canBeEndOfWord = true;\n    }\n\n    public bool Search(string word)\n    {\n        return dfs(word, 0, root);\n    }\n\n    private bool dfs(string word, int idx, TrieNode parent)\n    {\n        if(idx==word.Length)\n            return parent.canBeEndOfWord;\n        \n        if(word[idx]!=wildcard)\n        {\n            if(!parent.children.ContainsKey(word[idx]))\n                return false;\n            return dfs(word, idx+1, parent.children[word[idx]]);\n        }\n        \n        //Else: (current char in word is the wildcard character)\n        foreach(char c in parent.children.Keys)\n        {\n            if(dfs(word, idx+1, parent.children[c]))\n                return true; //As soon as we find a possible match, we stop and return true;\n        }\n        return false; //if no possible match is found after considering each and every child as the wildcard.\n    }\n}",
    "problemId": "design-word-search-data-structure",
    "statusDescription": "Accepted",
    "time": "0.42",
    "date": "2024-11-18T23:23:38.377Z",
    "memory": 57168,
    "stdout": "",
    "stderr": ""
}